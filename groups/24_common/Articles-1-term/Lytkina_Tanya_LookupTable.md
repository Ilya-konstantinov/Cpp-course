**Lookup Table (таблица поиска, LUT)**

**Введение**

Lookup table (таблица поиска) – это массив, который заменяет вычисление математической функции на выполнение программы простой операцией доступа к элементу по индексу. Это как прямая адресация. Такой метод сильно ускоряет работу, ведь чтение из памяти обычно быстрее, чем сложные расчеты или операции ввода-вывода.

**Принцип работы и отличия от хеш-таблицы**

Таблицы могут быть заранее вычислены и сохранены в статической памяти программы или рассчитаны на этапе запуска (или «предзагружены»), а на специальных платформах даже храниться в аппаратной части. Таблицы поиска используются для проверки входных данных – сравнивая их с допустимыми значениями из списка. В некоторых языках они содержат указатели на функции для обработки совпадений.

FPGA(специальная микросхема, которую можно многократно перепрограммировать для разных задач, как конструктор из логических блоков) активно применяют перестраиваемые таблицы поиска для реализации логики. Пример реализации:

A | B | Выход (A XOR B)

\--+---+--------------

0 | 0 | 0

0 | 1 | 1 - ввод 01 вывод сразу 1

1 | 0 | 1 - ввод 10 вывод сразу 1

1 | 1 | 0

В отличие от хеш-таблиц, где ключ k через хеш-функцию h(k) определяет слот для значения v, в таблице поиска значение лежит прямо по индексу k – доступ мгновенный.

**Типы таблицы поиска**

1.  **По размерности**

- 1D LUT: одномерная таблица для преобразования одного входа (e.g. яркость или один канал цвета RGB)
- 2D LUT: двумерные для двух входов (x; y); применяются в графике и моделировании для интерполяции поверхностей
- 3D LUT: трехмерные таблицы для цветокоррекции видео/изображений
- ND LUT (многомерные): 4D+ таблицы для сложных задач, как оптические свойства; требуют больше памяти

1.  **По динамике и доступу**

- Статические: предвычисленные, неизменяемые; для константных функций (e.g. sin(x))
- Динамические: обновляемые в runtime; для адаптивных систем
- Интерполированные: с линейной/кубической интерполяцией между точками для непрерывных данных

**Основные операции**

- Поиск: преобразование входного индекса в предвычисленное значение; О(1), т.к. происходит только чтение по адресус
- Интерполяция: линейная (1D, 2D), трилинейная (4D) или тетраэдральная (4D) для значений между узлами сетки
- Чтение/запись элемента: доступ к конкретной ячейке по индексу для статических/динамических таблиц
- Предвычисление (генерация): заполнение таблицы значениями функции в цикле или векторизацией
- Редактирование: изменение узлов сетки, очистка/восстановление кривых в редакторах

**Сложность**

1.  Поиск: О(1)

Операция состоит из двух фиксированных шагов:

- Квантование (округление) входа x в индекс _i_\=\\round() арифметических операций (деление, вычитание, округление)
- Чтение result = lut\[i\] – одно обращение к памяти по адресу.

Количество шагов не зависит от размера таблицы или входных данных, поэтому время выполнения постоянно.

1.  Интерполяция: О(1)

Количество участвующих узлов фиксировано для каждого типа. Все вычисления – константное количество умножений/сложений, независимо от размера сетки.

1.  Предвычисление – О(n)

Требуется вычислить и записать n значений функции для всех индексов:

for i in range(n):

lut\[i\] = f(x_min + i \* Δx)

сложность линейна от размера таблицы – О(n)

1.  Обновление элемента: О(1)

Прямая запись по известному индексу:

Lut\[i\] = new_number

Аналогично поиска – одно обращение к памяти по адресу, без перебора элементов. Время постоянно независимо от n.

**Преимущества**

- Высокая скорость работы: О(1) заменяет сложные вычисления (e.g. вычисление sin)
- Предсказуемость: постоянное время выполнения независимо от сложности функции
- Универсальность: сложные трансформации выполняются одной операцией

**Недостатки**

- Ограниченная точность: требуется интерполяция, которая впоследствии снижает скорость
- Высокие требования к памяти: 3D LUT 33<sup>3</sup> \= 35937 значений \* 3 канала \* 4 байта = 400 Кб; ND LUT растут экспоненциально О(r<sup>d</sup>)
- Время предвычилснеия: О(n) на заполнение таблицы; для больших LUT требуются минуты или даже часы
- Негибкость: изменение функции требует пересчета всей таблицы; не подходит для динамических данных

**Заключение**

Lookup Table (таблица поиска) – удобная структура данных для ускорения повторяющихся вычислений благодаря постоянному времени доступа О(1) и предсказуемости, что критично для реального времени. С другой стороны, высокие требования к памяти О(r<sup>d</sup>), ограниченная точность и негибкость при изменениях параметров делают ее неуниверсальной – подходит только для статичных задач с достаточным объемом памяти.

**Источники**

https://en.wikipedia.org/wiki/Lookup_table

https://hardwarebee.com/overview-of-lookup-tables-in-fpga-design/

https://i-us.ru/index.php/ius/article/view/16346/15387

https://ru.ruwiki.ru/wiki/Таблица_поиска