# SPQR trees

## Введение

**SPQR-дерево** – это деревообразная структура данных, используемая в теории графов для представления разбиения двусвязного графа на трёхсвязные компоненты. Каждая вершина SPQR-дерева связана с некоторым базовым графом (скелетом), и тип вершины указывает на форму этого подграфа. SPQR-дерево графа строится за линейное время O(|V|+|E|) и имеет линейный размер (количество всех вершин и рёбер пропорционально размерам исходного графа).

![SPQR-tree](SPQR.svg)

На рисунке цветами выделены различные трёхсвязные компоненты графа, а справа показаны соответствующие узлы S, P, Q, R с их скелет-графами. 

- узел S соответствует циклической структуре (в примере это зелёный треугольник); 
- узел P – двум вершинам с параллельными рёбрами (диполь, жёлтая полоса);
- узел R – жёсткой 3-связной компоненте (синий)
- узел Q – одиночному ребру (коричневый отрезок). 

Соседние узлы SPQR-дерева соединены виртуальными рёбрами, которые при «склейке» (сумме по клике - операции, при которой два подграфа соединяются, отождествляя общую пару вершин и удаляя служебное/"виртуальное" ребро между ними) восстанавливают исходный граф. 

### Типы вершин (S, P, Q, R)
- **S-узел (Series):** ассоциированный граф – простой цикл из ≥3 вершин. Аналог сериализации (последовательного соединения) графов


- **P-узел (Parallel):** ассоциированный граф – диполь (граф, состоящий из двух вершин, соединённых несколькими параллельными рёбрами) из двух вершин с ≥3 параллельными рёбрами (многократными ребрами). Аналог параллельного соединения графов


- **Q-узел (Quest):** ассоциированный граф – одиночное реальное ребро. Тривиальный случай для графа из одного ребра (встречается, когда нужно представить каждое реальное ребро)


- **R-узел (Rigid):** ассоциированный граф – произвольная 3-связная компонента, не являющаяся циклом или диполем. «Жёсткая» часть разложения: такие подграфы имеют единственное планарное вложение (каждое ребро пересекается не более чем с одним другим ребром, причем пересечение происходит только в общих вершинах, а не "посередине")


При построении графа из SPQR-дерева каждое ребро дерева связывает два виртуальных ребра в скелетах соседних узлов; удаляя эти виртуальные рёбра и склеивая соответствующие вершины, восстанавливают исходный граф как последовательность 2-кликовых сумм.

 >*Теорема 1.* Скелет-графы SPQR-дерева совпадают с трёхсвязными компонентами исходного графа: P-узлы — с «связками» параллельных рёбер, S-узлы — с полигонами (циклы), R-узлы — с простыми 3-связными подграфами. Размер SPQR-дерева (с учётом всех скелетов) линейно относится к размеру исходного графa.


## Построение 
SPQR-дерево двусвязного графа можно построить за линейное время O(|V|+|E|). Классический алгоритм Гатвингера и Мутцеля выполняет следующие шаги:


1. **Удаление параллельных рёбер.** Сначала сортируют все рёбра по концам (два прохода по блочной сортировке* - см. ниже "*") так, чтобы параллельные ребра оказались рядом. Каждую группу параллельных рёбер сворачивают в один P-узел (диполь), заменяя их одним виртуальным ребром. Остальной граф становится простым (без кратных рёбер)

2. **Разбиение по разделяющим вершинам.** Находят все пары точек сочленения (далее "2-разрезы"): если пара (u,v) разделяет граф, разбивают граф на две части, связывая в каждом подграфе вершины u,v виртуальным ребром. Повторяют, пока не останется 2-разрезов. Получается система так называемых "split-компонент" - подграфов без внутренних 2-разрезов. Эти компоненты ещё не однозначны: S-узлы в итоге представят циклы, которые могли быть разбиты на несколько треугольников.

3. **Классификация и слияние компонентов.** Каждую split-компоненту помечают как P (если она состоит из двух вершин с ≥2 рёбрами), S (если это треугольник), или R (остальное). Если две компоненты одного типа S или P соединены через виртуальные рёбра, их объединяют в один узел того же типа. Итоговые скелеты S-узлов – это простые циклы (полигон), P-узлов – диполи, R-узлов – простые 3-связные графы.

Альтернативно, можно последовательно вставлять рёбра по одному (или через ear-разложение* - способ построить двусвязный граф, начиная с цикла и добавляя пути с новыми внутренними вершинами). В частности, Ди Баттиста и Тамассия показали, что начиная с треугольника SPQR-дерево строится операциями insertEdge и splitEdge (добавление ребра и разбиение ребра на две части) за |E|–3 вставок ребёр и |V|–3 вставок вершин. Такая инкрементальная схема хорошо иллюстрирует принцип разделения на компоненты.


>> ***Блочная сортировка** - сортировка за линейное время,
если ключи лежат в ограниченном диапазоне. Как работает: создаём массив «корзин» (блоков). Каждый элемент кладём в корзину по значению ключа, затем обходим корзины по порядку. В SPQR: рёбра сортируются по парам вершин (u, v), номера вершин лежат в диапазоне 1..|V|, которые можно отсортировать - сначала по u, потом по v. Без сравнения (за O(∣E∣)). Эта сортировка и обеспечивает линейное время построения SPQR дерева

>> ***Ear-decomposition (ear-разложение)** - способ построить двусвязный граф шаг за шагом, добавляя к уже построенной части пути, которые «цепляются» за неё концами. Название из аналогии с организмом - сначала скелет (цикл), потом «уши» (простые пути). Считается, что граф G имеет ear-разложение, если существует последовательность: G0 ⊂ G1 ⊂ ⋯ ⊂ Gk = G ​такая, что: 
>> 1. G0 — простой цикл, 
>> 2. Gi = Gi−1 ∪ Pi, где Pi — ухо

>> **Ключевая теорема:** Граф двусвязен ⇔ у него существует ear-разложение


## Операции, применение
SPQR-дерево позволяет эффективно выполнять ряд операций над графом:

- **Поиск 2-разрезов (точек сочленения порядка 2).** Все пары вершин {u,v}, разрезающих граф на две части при их удалении, находятся по структуре SPQR-дерева. Если u,v – концы виртуального ребра между узлами (S или R), то разрез соответствует разделению через это ребро; если в P-узле есть несколько виртуальных рёбер между u и v, то каждый виртуальный ребро соответствует отдельной компоненте при удалении u,v; для S-узлов учитывают непараллельность или виртуальность ребра. Таким образом можно за линейное время перечислить все 2-разрезы графа
- **Перечисление всех планарных вложений.** Для планарного двусвязного графа SPQR-дерево кодирует свободу выбора вложения. 3-связный граф имеет единственное планарное вложение (R-узел «жёсткий» - rigid), но при 2-связности возможны повороты: между соединёнными виртуальными рёбрами можно «отражать» части графа. В частности, в P-узле можно переставлять блоки между виртуальными рёбрами в произвольном порядке, а в R-узле менять ориентацию относительно соседей. То есть, все различные планарные (комбинаторные) вложения задаются флипами R-узлов и перестановками P-узлов.

- **Динамические обновления графа.** SPQR-дерево поддерживает добавление рёбер и вершин в онлайн-режиме. Ди Баттиста и Тамассия описали операции insertEdge, splitEdge, insertVertex, позволяющие начать с простого S-узла (треугольника) и пошагово строить SPQR-дерево для заданного графа. Эти операции также применяются в динамических алгоритмах

- **Другие применения:** SPQR-деревья широко используются в алгоритмической геометрии и graph drawing (создание двумерных (иногда трёхмерных) изображений графов (структур из вершин и рёбер) для наглядного представления отношений между объектами). Например, они лежат в основе инкрементальных тестов планарности и планаризаций (оптимального добавления рёбер с минимальным числом пересечений), а также в задачах визуализации и раскладки графов. Также SPQR-деревья находят применение в вычислительной биологии - их применяют для анализа графов сборки геномов и изучения локальной родословной


## Асимптотика
Построение SPQR-дерева занимает O(|V|+|E|) времени. 

В алгоритме с доказательством этого линейного времени Гатвингер и Мутцель показывают, что все основные этапы (сортировка рёбер, поиск 2-разрезов через DFS и обработка стеком) выполняются за линейное время. *Теорема 1* утверждает, что итоговая структура содержит O(|V|+|E|) вершин и рёбер (линейный размер по отношению к графу), то есть память SPQR-дерева также O(|V|+|E|). 

Доказательство базируется на том, что скелет-графы образуют трёхсвязные компоненты, и никакие две S-узла или P-узла не сливаются (без потери трёхсвязности). Все алгоритмические шаги сводятся к переборам рёбер и вершинам с константными операциями, что обеспечивает требуемые оценки.


## Реализация
В практических системах SPQR-деревья реализуют, например, в библиотеке OGDF (для C++). 

Упрощённый псевдокод (реализации структуры):

````python
def build_spqr_tree(graph):
    # 1. Найти все двусвязные компоненты графа (в каждой строится отдельно SPQR-дерево)
    for comp in biconnected_components(graph):
        
        # 2. В каждой компоненте свернуть параллельные ребра в P-узлы
        split_parallel_edges(comp)

        # 3. Найти пары разделяющих вершин (2-разрезы) через DFS/алгоритм Тарьяна
        separators = find_separation_pairs(comp)

        # 4. Разбить компоненту по этим разделяющим парам и собрать split-компоненты
        split_components = split_graph(comp, separators)

        # 5. Классифицировать каждую split-компоненту как S, P или R
        for sc in split_components:
            if is_triangle(sc): mark_as_S(sc)
            elif is_bundle(sc): mark_as_P(sc)
            else: mark_as_R(sc)

        # 6. Если два S- или P-компонента связаны виртуальными ребрами, объединить их
        merge_adjacent_SP(split_components)

        # 7. Построить узлы SPQR-дерева из оставшихся компонент и соединить их по виртуальным ребрам
        # (для каждой пары свёрнутых рёбер сделать соединение узлов дерева)

````



## Преимущества/Недостатки

### Преимущества
- Однозначно кодирует структуру трёхсвязности графа и даёт универсальный инструмент для множества задач. 
- Позволяет быстро искать все 2-разрезы, получать все планарные вложения, поддерживать динамические изменения и объединять компоненты в лёгкие операции. 
- Благодаря линейному времени построения и размера оно эффективно даже для больших графов

### Недостатки
- Сложная реализация (много технических деталей DFS, стеков и специальных структур - сложное построение структуры). 
- Структура работает только для двусвязных графов (для произвольных графов требуется предварительно строить дерево блок–разрезов BC-tree). 
- Q-узлы (отдельные ребра) могут множиться при детальном разложении, что увеличивает число узлов дерева.
- Динамическое удаление ребер из SPQR-дерева сильно усложняет алгоритмы (необходимо перестраивать разбиение), поэтому SPQR-деревья чаще применяют для инкрементальных сценариев. 

Иными словами, практическая реализация требует большого объёма кода и аккуратного тестирования.

## Заключение
С какими структурами и алгоритмами тесно связаны SPQR-деревья (что стоит знать для их лучшего понимания):

- BC-дерево (block–cut tree)
→ SPQR — его «следующий уровень»
- Декомпозиции по клике (clique-sum)
- Ear-разложение
- Деревья DFS (Tarjan)
- динамическая планарность
- алгоритмы графовой визуализации
- изоморфизм планарных графов

All in all, SPQR-trees у нас:
- редко пишут вручную,
- часто используют неявно,
- оптимальный вариант, когда нужно понять внутреннюю структуру двусвязных графов.

Это пример структуры, где высокая сложность реализации полностью компенсируется универсальностью, точностью и асимптотической эффективностью.


## Источники

[SPQR-tree Construction via Ear Decompositions – Theory and Experiments](https://www.fim.uni-passau.de/fileadmin/dokumente/fakultaeten/fim/lehrstuhl/rutter/abschlussarbeiten/2022-Marcel-Posch-MA.pdf#:~:text=5.1%20Construction%20using%20Ear,can%20be%20constructed) - хорошая статься про SPQR, много интересного

[A linear time implementation of SPQR-trees](https://www.researchgate.net/publication/30508580_A_linear_time_implementation_of_SPQR-trees) - тут про линейность времени SPQR

---
поюзанное в процессе

[Сумма по клике Wikipedia](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BC%D0%BC%D0%B0_%D0%BF%D0%BE_%D0%BA%D0%BB%D0%B8%D0%BA%D0%B5)

[Блочная сортировка Wikipedia](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)

[SPQR tree Wikipedia](https://en.wikipedia.org/wiki/SPQR_tree#:~:text=If%20a%20planar%20graph%20is,SPQR%20tree%2C%20the%20different%20parts)

[SPQR для общего развития (отсюда черпалосьь вдохновение)](https://ru.wikipedia.org/wiki/SPQR)

---

[Visibility Rep. Extension (3/6): SPQR-Trees | Visualization of Graphs - Lecture 10](https://youtu.be/1HDRptUiYF0?si=WRJersrelo17xmJy) - серия коротких видео, в частности это - про SPQR

[SPQR-Trees and Block-Cut-Trees - Reducing Connectivity Requirements](https://www.youtube.com/live/n2Hqjphak3s) - одно большое добротное видео про SPQR


