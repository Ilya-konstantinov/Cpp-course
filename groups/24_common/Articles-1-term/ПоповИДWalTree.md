**Wavelet Tree (Вейвлет-дерево)**


**1. Введение**

Wavelet Tree (вейвлет-дерево) — это бинарное дерево, построенное по значениям массива. Каждый уровень дерева отвечает за разбиение элементов на две части по значению. Говоря другими словами это компактная структура данных, предназначенная для обработки запросов на массиве, связанных с порядком элементов, частотами и диапазонами. Данная структура широко используется в задачах спортивного программирования, обработке массивов и теории строк.
Несмотря на теоретическую мощь, Wavelet Tree редко применяется в промышленной разработке в явном виде. Это связано со сложностью реализации, повышенными требованиями к памяти и наличием более простых специализированных структур данных, которые в практических задачах оказываются быстрее и удобнее в сопровождении.


**2. Что же позволяет делать это дерово?**
Wavelet Tree позволяет эффективно отвечать на следующие типы запросов:
- поиск k-го по величине элемента на отрезке,
- подсчёт количества элементов, меньших заданного,
- определение частоты числа на подотрезке.


**3. Принцип построения**
Пусть дан массив `A` из `n` элементов.  
Строительство выполняется следующим образом:
1. Выбирается диапазон значений `[min, max]`.
2. На текущем уровне находится середина диапазона:
   mid = (min + max) / 2
3. Все элементы массива:
   - если `A[i] ≤ mid`, отправляются в левое поддерево,
   - иначе — в правое.
4. Дополнительно строится бинарный массив `B`, где:
   - `0` — элемент ушёл влево,
   - `1` — элемент ушёл вправо.
5. Процесс рекурсивно повторяется, пока диапазон не сократится до одного значения.


**4. Поддерживаемые операции**
Пусть `n` это диапозон значений, а `k` это размер массива

## 4.1. Поиск k-го по величине элемента на отрезке
Запрос:
kth(l, r, k) Находит k-й по величине элемент на подотрезке `[l, r]`.
Процесс работы запроса:
по массиву `B` определяется, сколько элементов ушло влево,
если `k` меньше этого количества — переходим в левое поддерево,
иначе — идём в правое.
Сложность:  
**O(log n)**, где `n` — диапазон значений.

## 4.2. Подсчёт элементов ≤ x на отрезке
Запрос:
count(l, r, x) Определяет количество элементов, не превышающих `x` на отрезке.
Процесс работы запроса:
Запрос начинается в корне в диапазоне значений `[min, max]`.
На каждом уровне:
если `x` < `mid` — выполняется переход только в левое поддерево;
если `x` ≥ `mid`:
все элементы из левого поддерева полностью учитываются в ответе,
затем выполняется переход в правое поддерево.
Границы `[l, r]` пересчитываются через битовый массив `B`.
Процесс повторяется до достижения листа.
Сложность:  
**O(log n)**.

## 4.3. Частота конкретного числа
Запрос:
freq(l, r, x) узнаёт, сколько раз число `x` встречается в диапазоне.
Процесс работы запроса:
Запрос сводится к разности двух запросов типа count, а именно
freq(l, r, x) = count(l, r, x) - count(l, r, x - 1)
Каждый из запросов count выполняется за O(log n).
В результате получается точное количество вхождений числа `x` на отрезке.
Сложность:
**O(log n)**.


**5. Сложность и память**
- Построение: **O(k log n)**
- Запросы: **O(log n)**
- Память: **O(k log n)**
Где:
- `k` — размер массива,
- `n` — диапазон значений.


**6. Пример**
Пусть дан массив:
A = [3, 1, 4, 1, 5, 9, 2]
Диапазон значений:  
[min, max] = [1, 9]

### Шаг 1. Корневой уровень
mid = 5
Разбиение:
- влево (≤ 5):  [3, 1, 4, 1, 5, 2]
- вправо (> 5): [9]
Битовый массив:
B = [0, 0, 0, 0, 0, 1, 0]

### Шаг 2. Узел [1, 5]
mid = 3
- ≤ 3 → [3, 1, 1, 2]
- > 3 → [4, 5]
B₁ = [0, 0, 1, 0, 1, 0]

### Шаг 3. Узел [1, 3]
mid = 2
- ≤ 2 → [1, 1, 2]
- > 2 → [3]
B₂ = [1, 0, 0, 0]

### Шаг 4. Узел [1, 2]
mid = 1
- ≤ 1 → [1, 1]
- > 1 → [2]
B₃ = [0, 0, 1]


**7. Практическое применение**
Wavelet Tree применяется в:
- поиске статистик порядка,
- обработке больших массивов,
- задачах на медиану,
- анализе последовательностей,
- сжатии данных.


**8. Преимущества и недостатки**
### Преимущества:
- Быстрые запросы.
- Универсальность.
- Работает с диапазонами.

### Недостатки:
- Сложность реализации.
- Большой расход памяти.
- Требует аккуратной индексации.


**9. Заключение**
Wavelet Tree — это мощная структура данных, сочетающая бинарные деревья и методы разбиения диапазонов. Она особенно эффективна в задачах, где требуется многократная работа с порядковыми статистиками на подотрезках.


**10. Источники**
1. Competitive Programming Handbook — Antti Laaksonen  
2. cp-algoritm.ru — Wavelet Tree  
3. GeeksForGeeks — Wavelet Tree Data Structure  
4. Документация e-maxx.ru