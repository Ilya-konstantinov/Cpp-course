## 1. ЧТО ТАКОЕ ДЕРЕВО МЕРКЛА?
**Дерево Меркла** — это специальная структура данных, которая помогает быстро проверять большие объёмы информации. Например, если есть 1000 документов и надо убедиться, что ни один из них не изменился. Проверять каждый документ по отдельности — долго и неудобно. Дерево Меркла решает эту проблему. 

Простыми словами: это "дерево" из хэшей, где каждый лист — это хэш документа, а корень — один хэш, который представляет все документы сразу.

<hr style="height: 3px; border: none; background: grey;">

## 2. КАК РАБОТАЕТ?

### 2.1: ХЭШИРОВАНИЕ ДАННЫХ

Каждый документ пропускается через криптографическую хеш-функцию, которая создаёт уникальный "цифровой отпечаток" фиксированной длины.

**Пример хеширования:**

* "Привет" → "a1b2c3d4e5f6..."
* "Мир" → "7g8h9i0j1k2l..."

---

### 2.2: ПОСТРОЕНИЕ ДЕРЕВА

Из полученных хешей строится бинарное дерево:

**Процесс построения:**
1. Хеши документов становятся **листьями дерева**
2. Пары листьев объединяются и вычисляется новый хеш
3. Процесс повторяется рекурсивно до получения **корневого хеша**

**Пример для 4 документов:**
<pre>
┌─────────────────────────────────────┐
│        Корень (hash(AB + CD))       │
│                 │                   │
│          ┌──────┴──────┐            │
│      Хеш A+B        Хеш C+D         │
│        │    │        │    │         │
│    Хеш A  Хеш B  Хеш C  Хеш D       │
│      │      │      │      │         │
│    Док A  Док B  Док C  Док D       │
└─────────────────────────────────────┘
</pre>

--- 

### 2.3: ПРОВЕРКА ДАННЫХ

**Чтобы проверить документ A:**
<pre>
┌─────────────────────────────────────────────────────────┐
│                    ПРОВЕРКА ДОКУМЕНТА                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│    [ИЗВЕСТНЫЙ КОРЕНЬ]                                   │
│           ║                                             │
│    [Вычисленный корень] ← СРАВНИВАЕМ                    │
│           ║                                             │
│    hash(AB + CD)                                        │
│        ╱       ╲                                        │
│  hash(A+B)   hash(C+D)  ← БЕРЁМ ИЗ ДОКАЗАТЕЛЬСТВА       │
│     ╱   ╲                                               │
│ hash(A) hash(B)  ← БЕРЁМ ИЗ ДОКАЗАТЕЛЬСТВА              │
│    ║                                                    │
│  [hash(A)] ← ВЫЧИСЛЯЕМ ИЗ ДОКУМЕНТА A                   │
│    ║                                                    │
│  ДОКУМЕНТ A                                             │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  РЕЗУЛЬТАТ:                                             │
│  •    Корни совпали → документ подлинный                │
│  •    Корни не совпали → документ изменён               │
└─────────────────────────────────────────────────────────┘
</pre>

<hr style="height: 3px; border: none; background: grey;">

## 3. ЗАЧЕМ ЭТО НУЖНО?

### 1: БЛОКЧЕЙН
* В каждом блоке хранится корень Меркла всех транзакций
* Можно быстро проверить любую транзакцию, не проверяя весь блок
например: в блоке 2000 транзакций, проверяем одну за 11 шагов вместо 2000

---

### 2: СИСТЕМЫ КОНТРОЛЯ ВЕРСИЙ
* git хранит хэши файлов в дереве Меркла
* Можно быстро найти изменённые файлы
* Экономит место и ускоряет работу

---

### 3: ПРОВЕРКА ЗАГРУЖЕННЫХ ФАЙЛОВ
* Скачиваете файл из интернета
* Проверяете его хэш
* Убеждаетесь, что файл не повреждён и не подделан

<hr style="height: 3px; border: none; background: grey;">

## 4. АНАЛИЗ СЛОЖНОСТИ 

### 4.1
Пусть у нас есть `n` элементов (например, транзакций).

**Процесс построения:**
- Хеширование каждого элемента: `n` операций
- Объединение пар на первом уровне: `n/2` операций  
- Объединение пар на следующем уровне: `n/4` операций
- Продолжаем до корня: `1` операция

**Общее количество операций:** n + n/2 + n/4 + ... + 1 ≈ 2n

**Сложность:** `O(n)` (линейная)

Пример для n = 8:   8 + 4 + 2 + 1 = 15 операций

Пример для n = 16:   16 + 8 + 4 + 2 + 1 = 31 операций

> Операций примерно в **2 раза больше**, чем элементов.

---

### 4.2
**Высота дерева:** `log₂(n)` уровней

**Примеры высоты:**
- 4 элемента → 2 уровня
- 8 элементов → 3 уровня  
- 16 элементов → 4 уровня
- 1024 элемента → 10 уровней

**Процесс проверки:**
1. Хеширование данных листа: **1 операция**
2. На каждом уровне: **1 операция сравнения**
3. Всего: `log₂(n) + 1` операций

**Сложность:** `O(log n)` (логарифмическая)

---

### 4.3

**Для 1 000 000 транзакций:**
- Построение: ~2 000 000 операций (быстро)
- Проверка одной транзакции: ~20 операций (очень быстро)
- Доказательство: ~20 хэшей (мало данных)

Без дерева Меркла пришлось бы проверять все 1 000 000 транзакций или хранить все 1 000 000 хэшей для проверки.

<hr style="height: 3px; border: none; background: grey;">

# 5. ПРОГРАММА ПРОЕКТА
## merkletree.py
```python
# дерево меркла

import hashlib
# узел дерева
class MerkleNode:
    def __init__(self, hash_value):
        self.hash = hash_value  # хэш узла
        self.left = None        # левый узел
        self.right = None       # правый узел

# вычислить хэш SHA-256
def calculate_hash(data):
    # преобразуем строку в байты и вычисляем хэш
    return hashlib.sha256(data.encode()).hexdigest()

# дерево Меркла - основная структура
class MerkleTree:
    def __init__(self, data_list):
        # создаём дерево из списка данных
        self.data = data_list # исходные данные
        self.leaves = [] # листья дерева
        self.root = None # корневой узел
        self.build_tree() # строим дерево
    
    def build_tree(self):
        # создаём листья - хэшируем каждый элемент
        for item in self.data:
            leaf_hash = calculate_hash(item)
            self.leaves.append(MerkleNode(leaf_hash))
        
        # строим дерево снизу вверх
        current_level = self.leaves.copy() # начинаем с листьев
        while len(current_level) > 1: # пока не останется корень
            next_level = []
            # обрабатываем узлы парами
            for i in range(0, len(current_level), 2):
                left = current_level[i]
                # если нет пары, используем тот же узел
                right = current_level[i+1] if i+1 < len(current_level) else left
                # объединяем хэши
                combined = left.hash + right.hash
                parent_hash = calculate_hash(combined)
                # создаём родительский узел
                parent = MerkleNode(parent_hash)
                parent.left = left
                parent.right = right
                next_level.append(parent)
            current_level = next_level # переходим на уровень выше
        self.root = current_level[0] if current_level else None
    def get_root(self):
        # возвращаем корневой хэш (представляет все данные)
        return self.root.hash if self.root else ""
    def verify(self, item):
        # проверяем есть ли элемент в дереве
        item_hash = calculate_hash(item) # хэш искомого элемента
        for leaf in self.leaves:
            if leaf.hash == item_hash:
                return True
        return False
    def get_info(self):
        # информация о дереве
        height = 0
        n = len(self.leaves)
        while n > 0:
            height += 1
            n //= 2
        return {
            'items': len(self.data), # сколько элементов
            'root': self.get_root()[:16] + "...", # начало корня
            'height': height # высота дерева
        }

# тест
if __name__ == "__main__":
    test_data = ["тест1", "тест2", "тест3"]
    tree = MerkleTree(test_data)
    print("тест:")
    print(f"корень: {tree.get_root()[:20]}...")
    print(f"проверка 'тест1': {tree.verify('тест1')}")
    print(f"проверка 'фейк': {tree.verify('фейк')}")
    info = tree.get_info()
    print(f"элементов: {info['items']}")
    print(f"высота: {info['height']}")
```

## main.py
```python
#программа проекта

from merkletree import MerkleTree
import time

def main():
    print("запуск программы 'дерево меркла':\n")
    
    # 1. пример
    print("1. пример")
    print("покупки:")
    покупки = ["хлеб 50р", "молоко 80р", "сыр 200р", "йогурт 60р"]
    for item in покупки:
        print(f"- {item}")
    print("\nстроим дерево...")
    дерево1 = MerkleTree(покупки)
    корень1 = дерево1.получить_корень()
    print(f"\nкорень дерева: {корень1[:12]}...")
    print(f"длина хэша: {len(корень1)} символа\n")
    print("проверка:")
    if дерево1.проверить("хлеб 50р"):
        print("хлеб 50р - найден")
    else:
        print("хлеб 50р - не найден")
    if дерево1.проверить("шоколад 100р"):
        print("шоколад 100р - найден")
    else:
        print("шоколад 100р - не найден")
    print("\n" + "-" * 40)
    
    # 2. пример из блокчейна
    print("2. пример из блокчейна\n")
    print("транзакции:")
    транзакции = [
        "TX1: анна → борис: 1 BTC",
        "TX2: борис → виктор: 0.5 BTC"
    ]
    for tx in транзакции:
        print(tx)
    print("\nстроим дерево для блока...")
    дерево2 = MerkleTree(транзакции)
    корень2 = дерево2.получить_корень()
    print(f"\nкорень: {корень2[:16]}...")
    проверка_транзакция = "TX2: борис → виктор: 0.5 BTC"
    if дерево2.проверить(проверка_транзакция):
        print(f"проверка TX2: есть в блоке")
    else:
        print(f"проверка TX2: нет в блоке")
    print("\n" + "-" * 40)
    
    # 3. пример
    print("3. пример\n")
    документы = ["паспорт 123456", "диплом 654321", "снилс 987654"]
    print("исходные документы:")
    for doc in документы:
        print(f"- {doc}")
    print("\nстроим исходное дерево...")
    исходное_дерево = MerkleTree(документы)
    исходный_корень = исходное_дерево.получить_корень()
    print(f"исходный корень: {исходный_корень[:12]}...")
    print("\nдокумент 'паспорт 123456' изменён на 'паспорт 999999'")
    измененные_документы = ["паспорт 999999", "диплом 654321", "снилс 987654"]
    print("\nстроим новое дерево...")
    новое_дерево = MerkleTree(измененные_документы)
    новый_корень = новое_дерево.получить_корень()
    print(f"новый корень: {новый_корень[:12]}...")
    if исходный_корень != новый_корень:
        print("изменение обнаружено!")
    else:
        print("ошибка: изменение не обнаружено")
    print("\n" + "-" * 40)
    
    # 4. скорость работы
    print("4. скорость работы\n")
    print("тестируем скорость построения...")
    тестовые_данные = [f"элемент {i}" for i in range(1000)]
    start_time = time.time()
    тестовое_дерево = MerkleTree(тестовые_данные)
    build_time = time.time() - start_time
    print(f"построение дерева из 1000 элементов: {build_time:.3f} сек")
    print("\nтестируем скорость проверки...")
    проверяемый_элемент = "элемент 500"
    start_time = time.time()
    for _ in range(100):
        тестовое_дерево.проверить(проверяемый_элемент)
    verify_time = (time.time() - start_time) / 100
    print(f"проверка элемента в дереве из 1000 элементов: {verify_time:.5f} сек")
    print("\nдля 1 млн транзакций:")
    print("без дерева: 1 млн проверок")
    print("с деревом: ~20 проверок (log₂(1,000,000) ≈ 20)")
    print("\n" + "=" * 40)
    print("программа завершена")

if __name__ == "__main__":
    main()
```

<hr style="height: 3px; border: none; background: grey;">

## 6. ПРИМЕРЫ ВЫВОДА

запуск программы "дерево меркла"

---

### 6.1
**покупки:**
- хлеб 50р
- молоко 80р
- сыр 200р
- йогурт 60р

**корень дерева:** a1b2c3d4e5f6...

**длина хэша:** 64 символа

**проверка:**
* хлеб 50р - найден
* шоколад 100р - не найден

---

### 6.2

**транзакции:**
* TX1: анна → борис: 1 BTC
* TX2: борис → виктор: 0.5 BTC

**корень:** 7f83b1657ff1fc53...

**проверка TX2:** есть в блоке

---

### 6.3
документ "паспорт 123456" изменён на "паспорт 999999"

**исходный корень:** d4e5f6a7b8c9...

**новый корень:** f1a2b3c4d5e6...

изменение **обнаружено!**

---

### 6.4
**построение дерева из 1000 элементов:** 0.001 сек
**проверка элемента в дереве из 1000 элементов:** 0.00001 сек

**для 1 млн транзакций:**
* без дерева: 1 млн проверок
* с деревом: ~20 проверок

---

программа завершена

<hr style="height: 3px; border: none; background: grey;">

## 7. ИСТОЧНИКИ
   - https://ru.wikipedia.org/wiki/Хеш-функция
   - https://ru.wikipedia.org/wiki/SHA-2
   - https://pythonworld.ru/
   - https://ru.wikipedia.org/wiki/Временная_сложность_алгоритма
   - https://docs.python.org/3/library/hashlib.html (англ. с переводом)