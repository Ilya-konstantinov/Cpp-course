# Алгоритм Монте-Карло как способ моделирования неопределённости

## Введение

Во многих задачах математики и информатики точное решение либо чрезвычайно сложно, либо практически невозможно получить аналитически. Особенно это характерно для задач, связанных с вероятностями, большим числом состояний и неполной информацией. Одним из универсальных методов работы с такими задачами является алгоритм Монте-Карло — подход, основанный на моделировании случайных экспериментов и статистической обработке результатов.

Цель данной работы — показать суть алгоритма Монте-Карло, объяснить, почему он работает, и продемонстрировать его применение на примере карточной игры покер, где точный перебор всех возможных исходов крайне затруднён.

---

## Почему метод называется «Монте-Карло»

Название алгоритма связано с одноимённым районом Монако, известным своими казино. Аналогия заключается в том, что метод, как и азартные игры, опирается на случайность, повторение экспериментов и статистическое усреднение. Однако, в отличие от азартных игр, здесь случайность используется строго контролируемо и служит инструментом вычисления.

---

## Суть алгоритма Монте-Карло

Алгоритм Монте-Карло — это вероятностный алгоритм, в котором искомая величина представляется в виде математического ожидания случайной величины, а затем приближённо вычисляется с помощью большого числа случайных экспериментов.

Общая идея метода состоит в следующем:

- Формулируется случайный эксперимент, связанный с задачей.
- Вводится случайная величина, значение которой зависит от результата эксперимента.
- Проводится большое число независимых экспериментов.
- Среднее значение результатов используется как приближение искомой величины.

Корректность метода обеспечивается законом больших чисел: при увеличении числа экспериментов среднее значение стремится к истинному математическому ожиданию.

---

## Проблема точного расчёта вероятностей в покере

Покер является классическим примером задачи с:

- огромным числом возможных состояний;
- неполной информацией;
- сложными правилами сравнения исходов.

Даже в простой ситуации (двое игроков, часть карт известна) число возможных раздач исчисляется сотнями тысяч и миллионами. Полный перебор всех комбинаций возможен лишь в ограниченных случаях и требует значительных вычислительных ресурсов.

Поэтому на практике используются приближённые методы, и прежде всего — Монте-Карло.

---

## Применение Монте-Карло в покере

В покере алгоритм Монте-Карло применяется для оценки так называемой equity руки — ожидаемой доли банка, которую игрок получит при вскрытии карт.

Алгоритм работает следующим образом:

- Фиксируются известные карты игрока и карты на столе.
- Из колоды удаляются все уже использованные карты.
- Случайным образом:
  - раздаются карты оппоненту;
  - добираются недостающие карты стола.
- Определяется лучшая покерная комбинация каждого игрока.
- Фиксируется результат (победа, поражение или ничья).
- Эксперимент повторяется много раз.

Доля выигрышных исходов стремится к истинной вероятности победы, а средний результат — к математическому ожиданию выигрыша.

---

## Математическое обоснование

Пусть случайная величина $X$ принимает значение:

- $1$, если игрок выигрывает;
- $0$, если проигрывает.

Тогда вероятность победы равна математическому ожиданию этой случайной величины:

$$
P(\text{win}) = \mathbb{E}[X]
$$

Алгоритм Монте-Карло вычисляет приближение этого ожидания по формуле:

$$
\mathbb{E}[X] \approx \frac{1}{N} \sum_{i=1}^{N} X_i
$$

где $N$ — число симуляций.  
Погрешность убывает пропорционально

$$
\frac{1}{\sqrt{N}},
$$

что делает метод эффективным даже при относительно небольшом числе экспериментов.

---

## Преимущества и ограничения метода

### Преимущества

- простота реализации;
- универсальность;
- независимость от размерности пространства состояний;
- применимость к задачам, где аналитическое решение отсутствует.

### Недостатки

- результат является приближённым;
- высокая точность требует увеличения числа симуляций;
- время работы линейно зависит от количества экспериментов.

Тем не менее, на практике метод позволяет получать достаточно точные оценки за приемлемое время.

---

## Заключение

Алгоритм Монте-Карло является мощным инструментом для решения задач, где точный расчёт невозможен или слишком сложен. На примере покера видно, что случайность в данном случае не является недостатком, а, напротив, становится источником информации. Многократное моделирование случайных раздач позволяет приблизиться к истинным вероятностям и принимать рациональные решения в условиях неполной информации.

Таким образом, метод Монте-Карло демонстрирует, как случайность и строгая математика могут эффективно дополнять друг друга.

---

## Асимптотика

Пусть:

- $N$ — число симуляций (trials).

В каждой симуляции:

- генерируется одна случайная раздача;
- определяется лучшая покерная комбинация из 7 карт.

Для оценки силы руки используется перебор всех 5-карточных подмножеств из 7 карт:

$$
\binom{7}{5} = 21
$$

То есть:

- одна оценка руки выполняется за $O(1)$ (константное число операций);
- в каждой симуляции оцениваются две руки (игрок и оппонент).

Итого, стоимость одной симуляции — константа:

$$
O(1)
$$

Таким образом, общая временная сложность алгоритма:

$$
O(N)
$$

Время работы линейно зависит от числа симуляций, что является ключевым преимуществом метода Монте-Карло.

---
Пример реализация кода на питоне
```
import random
from itertools import combinations
from collections import Counter

ranks = '23456789TJQKA'  # все номиналы карт
suits = 'shdc'  # все масти карт

deck = [r + s for r in ranks for s in suits]
rank_value = {r: i for i, r in enumerate(ranks, 2)}


def parse_cards(s):
    if not s.strip():
        return []
    cards = s.split()
    for c in cards:
        if len(c) != 2 or c[0] not in ranks or c[1] not in suits:
            raise ValueError(f"Некорректная карта: {c}")
    if len(set(cards)) != len(cards):
        raise ValueError("Карты не должны повторяться")
    return cards


def evaluate(cards):
    values = sorted([rank_value[c[0]] for c in cards], reverse=True)
    suits_ = [c[1] for c in cards]

    counts = Counter(values)
    freq = sorted(counts.items(), key=lambda x: (-x[1], -x[0]))

    is_flush = len(set(suits_)) == 1

    is_straight = (
            values == list(range(values[0], values[0] - 5, -1)) or
            values == [14, 5, 4, 3, 2]
    )
    high_straight = 5 if values == [14, 5, 4, 3, 2] else values[0]

    if is_straight and is_flush:
        return (8, high_straight)  # стрит флеш
    if freq[0][1] == 4:
        return (7, freq[0][0], freq[1][0])  # каре
    if freq[0][1] == 3 and freq[1][1] == 2:
        return (6, freq[0][0], freq[1][0])  # фул хаус
    if is_flush:
        return (5, values)  # флеш
    if is_straight:
        return (4, high_straight)  # стрит
    if freq[0][1] == 3:
        return (3, freq[0][0],
                sorted([v for v in values if v != freq[0][0]], reverse=True))  # сет
    if freq[0][1] == 2 and freq[1][1] == 2:
        p1, p2 = freq[0][0], freq[1][0]
        kicker = freq[2][0]
        return (2, max(p1, p2), min(p1, p2), kicker)  # две пары
    if freq[0][1] == 2:
        return (1, freq[0][0],
                sorted([v for v in values if v != freq[0][0]], reverse=True))  # пара
    return (0, values)  # старшая карта


def best_hand(cards7):
    return max(evaluate(list(c)) for c in combinations(cards7, 5))


def monte_carlo_poker_probs(my_hand, board, trials=300_000):
    used = set(my_hand + board)
    if len(used) != len(my_hand) + len(board):
        raise ValueError("Карты повторяются")

    if len(board) > 5:
        raise ValueError("На столе не может быть больше 5 карт")

    remaining = [c for c in deck if c not in used]
    need = 5 - len(board)

    wins = ties = losses = 0

    for _ in range(trials):
        cards = random.sample(remaining, 2 + need)
        opp_hand = cards[:2]
        full_board = board + cards[2:]

        my_best = best_hand(my_hand + full_board)
        opp_best = best_hand(opp_hand + full_board)

        if my_best > opp_best:
            wins += 1
        elif my_best == opp_best:
            ties += 1
        else:
            losses += 1

    return wins / trials, ties / trials, losses / trials


def main():
    print("Texas Hold'em Monte-Carlo")
    print("Формат карт: As Ks Qd 2c\n")

    try:
        my_hand = parse_cards(input("Введите ваши карты (2, через пробел): "))
        if len(my_hand) != 2:
            raise ValueError("Нужно ввести ровно 2 карты")

        board = parse_cards(input("Введите карты стола (0–5, через пробел): "))
        if len(board) not in {0, 3, 4, 5}:
            raise ValueError("На столе должно быть 0, 3, 4 или 5 карт")

        trials = int(input("Число симуляций (рекомендую 30000-50000): "))

        win, tie, lose = monte_carlo_poker_probs(my_hand, board, trials)

        print("\nРезультат:")
        print(f"Win : {win:.4f}")
        print(f"Tie : {tie:.4f}")
        print(f"Lose: {lose:.4f}")
        print(f"Equity: {win + 0.5 * tie:.4f}")

    except Exception as e:
        print("Ошибка:", e)

main()
```
