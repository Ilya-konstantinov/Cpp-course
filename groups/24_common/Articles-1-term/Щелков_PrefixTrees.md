
# Сжатые префиксные деревья: Radix Tree и Patricia Trie

## **Введение**

В настоящее время в базах данных, в сетевых приложениях, в компиляторах и в средствах автодополнения часто нужен быстрый поиск и хранение строковых ключей с общими префиксами. Решать такие задачи с помощью линейного перебора строк или обычными ассоциативными контейнерами становится неэффективно при увеличении количества данных, так как увеличиваются затраты по времени и памяти. Для эффективного решения подобных задач применяются префиксные деревья.

Однако классическое префиксное дерево - trie требует большого количества вершин и, соответственно памяти. Для устранения этой проблемы были созданы сжатые префиксные деревья, самые популярные из них: Radix Tree и Patricia Trie. Эти структуры сохраняют преимущества trie, но при этом значительно уменьшают размер дерева за счёт сжатия однонаправленных цепочек вершин.

Я выбрал Radix Tree и Patricia Trie, потому что на них можно наглядно показать идеи оптимизации, и они широко применяются на практике: Например в сетевой маршрутизации и для индексирования строк.
## **Radix Tree**

### Что это?
**Radix Tree** - древовидная структура данных, оптимизированная версия обычного trie. Если в обычном trie каждая вершина - это один отдельный символ, то в Radix tree несколько вершин могут объединится в одно ребро, которое будет хранить подстроку

**Пример:**

Допустим, нам нужно хранить следующий список слов:
* dog
* dot
* cat
* car

Покажем наглядно, как бы выглядели обычное префиксное дерево и его оптимизированная версия - Radix Tree на этом списке:


<p align="center">
  <img src="https://raw.githubusercontent.com/BaksArt/PrefixTrees/refs/heads/main/assets/Trie_example.svg" width="45%" />
  <img src="https://raw.githubusercontent.com/BaksArt/PrefixTrees/refs/heads/main/assets/RadixTree_example.svg" width="45%" />
</p>

Основная идея Radix Tree - сжимать цепочки вершин с единственным потомком в одно ребро, храня сразу несколько символов вместо одного, и таким образом:
* Уменьшается количество вершин
* Снижается глубина дерева
* Ускоряются операции поиска и вставки

### Алгоритм

#### Принцип хранения данных

Radix Tree хранится как префиксное дерево, в котором каждый узел может иметь несколько потомков, а рёбра между узлами помечены строками разной длины, а не отдельными символами.
В каждом узле хранится:
* набор исходящих рёбер (ключ -> подстрока)
* указатели на дочерние узлы
* признак окончания ключа

Все ключи в дереве располагаются так, что общий префикс хранится ровно один раз, а разветвление происходит только в точках, где строки различаются.

#### Вставка

1. Начинаем с корня
2. Сравниваем текущую часть вставляемого ключа с подстроками на исходящих рёбрах.

3. Проверяем:

* Если подстрока ребра полностью совпала, то переходим в дочерний узел и продолжаем

* Если подстрока совпала частично, то разделяем ребро на два:
  * общий префикс
  * оставшаяся часть старого ребра и новая ветка для вставляемого ключа.

* Если вообще совпадений нет, то создаем новое ребро с оставшейся частью ключа

После полного добавления строки пометить вершину как терминальную (это значит что в этой вершине у нас заканчивается какое-то слово)

#### Поиск 
1. Начинаем с корня
2. На каждом шаге ищем ребро, подстрока которого является префиксом оставшейся части ключа
3. Если подстрока совпала полностью - переходим к дочернему узлу
4. Если совпадение невозможно или символы расходятся, значит такой ключ отсутствует
5. Ключ найден, если после полного сопоставления достигнута терминальная вершина

> Поиск завершается сразу при первом несовпадении, именно это и делает его эффективным

#### Удаление
1. Находим вершину, соответствующую удаляемому ключу, и снимаем с нее терминальность

2. Поднимаемся вверх по пути, и для каждой вершины если она не терминальная и имеет ровно одного потомка выполняем сжатие:
  * Удаляем текущую нетерминальную вершину с единственным потомком и заменяем два рёбра одним ребром с объединённой меткой

3. Останавливаемся, как только условие сжатия перестало выполняться

### Ассимптотика алгоритмов
Для удобства обозначим:

* L - длина ключа
* N - количество ключей в дереве

| Операция | Cложность |
| -------- | --------- |
| Поиск    | O(L)      |
| Вставка  | O(L)      |
| Удаление | O(L)      |

---

### Доказательство ассимптотики O(L)

1. На каждом шаге алгоритмов (поиск, вставка, удаление) происходит сравнение не более одного раза для каждого символа ключа
2. Несмотря на то, что рёбра содержат строки, суммарная длина всех сравнений за одну операцию не превышает длину ключа L
3. Для удаления, не смотря на то что в нем мы сначала ищем вершину, а потом идем обратно к корню и сжимаем дерево, ассимптотика все равно остается O(L), так как удаление состоит из двух линейных этапов: поиска ключа и обратного прохода с проверками и сжатием. Формально это даёт O(2L), однако так как постоянные множители не учитываются, асимптотическая сложность удаления равна O(L)

Следовательно, общее количество операций линейно зависит от длины ключа, что и даёт сложность O(L)

## **Patricia Trie**

### Что это?
Patricia Trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric) - разновидность сжатого префиксного дерева, частный случай Radix Tree, изначально разработанный для эффективного хранения и поиска двоичных ключей. В отличие от обычного trie, Patricia Trie не хранит цепочки вершин с единственным потомком, а вместо этого сохраняет только точки ветвления, указывая позицию первого различающегося бита или символа

Если в обычном trie каждая вершина соответствует одному символу, то в Patricia Trie:
* Промежуточные вершины без ветвления отсутствуют
* Каждый узел соответствует реальному различию ключей

Рассмотрим на прошлом примере, чтобы увидеть разницу между Radix Tree и Patricia Trie:


<p align="center">
  <img src="https://raw.githubusercontent.com/BaksArt/PrefixTrees/refs/heads/main/assets/RadixTree_example.svg" width="45%" />
  <img src="https://raw.githubusercontent.com/BaksArt/PrefixTrees/refs/heads/main/assets/Patricia_example.svg" width="45%" />
</p>

Основная идея Patricia Trie - хранить не весь путь, а вопросы которые нужно задать ключу, например: "Какой символ на позиции 0?" или "Какой символ на позиции 2?"

> Как можно заметить, в Patricia Trie символы a и o вообще не хранятся, потому что они одинаковы внутри своих групп

**Почему Patricia Trie ещё лучше Radix Tree?**

Radix Tree:
* Хранит подстроки
* Сравнивает символы подряд

Patricia Trie
* Хранит только индексы различий
* Перескакивает через одинаковые части

Получаем минимально возможное количество узлов

### Алгоритм

#### Принцип хранения данных
Patricia Trie хранится как сжатое префиксное дерево, в котором каждый узел содержит:
* Позицию символа или бита, по которому происходит сравнение
* Ссылки на дочерние узлы
* Признак окончания ключа или указание на хранимый ключ

Ветвление происходит только в местах, где ключи действительно различаются, а одинаковые префиксы не создают отдельные вершины

#### Вставка
1. Начинаем с корня
2. Сравниваем вставляемый ключ с ключами, хранящимися в узлах, переходя по индексам различающихся символов
3. Находим первую позицию, где новый ключ отличается от существующего
4. Создаём новую вершину, соответствующую этой позиции различия
5. Подключаем старый и новый ключи как потомков новой вершины
6. Помечаем соответствующий узел как терминальный
#### Поиск
1. Начинаем с корня
2. В каждом узле проверяем символ ключа на позиции, хранящейся в узле
3. В зависимости от значения символа переходим к соответствующему потомку.
4. Поиск продолжается до листа.
5. Ключ найден, если в листе хранится точно совпадающий ключ.

> Поиск сразу переходит к позициям, где ключи могут различаться, т.е. он не сравнивает все символы подряд

#### Удаление
1. Находим лист, соответствующий удаляемому ключу
2. Удаляем ключ из листа т.е. снимаем терминальность
3. Если родительская вершина после удаления имеет только одного потомка:
    * Удаляем эту вершину
    * Соединяем её родителя напрямую с оставшимся потомком

4. Продолжаем подниматься вверх, пока возможно сжатие
5. Останавливаемся, когда вершина либо терминальная, либо имеет более одного потомка

### Ассимптотика алгоритмов
Ассимптотика аналогична Radix Tree:
| Операция | Cложность |
| -------- | --------- |
| Поиск    | O(L)      |
| Вставка  | O(L)      |
| Удаление | O(L)      |

### Доказательство ассимптотики O(L)

1. При поиске, вставке и удалении анализируются только позиции различий ключей, количество которых не превышает длину ключа L
2. Каждый символ или бит ключа участвует в сравнении не более одного раза
3. При удалении алгоритм состоит из линейного прохода вниз при поиске ключа и линейного подъёма вверх с проверками и возможным сжатием, что также дает O(L) (аналогично удалению в Radix Tree)



## **Области применения**

Сжатые префиксные деревья, применяются в задачах, где требуется быстрый поиск по ключам и минимальное использование памяти. Во-первых это **сетевое программирование**, где Patricia Trie используется для реализации алгоритма longest prefix match при маршрутизации IP-пакетов. В этом случае каждый узел соответствует позиции различающегося бита IP-адреса.

В **базах данных** и **key-value хранилищах** Radix Tree применяется для построения компактных индексов строковых ключей.

В **файловых системах** Radix Tree используется для хранения и быстрого поиска путей к файлам и каталогам. Поскольку пути имеют общие префиксы, сжатое префиксное дерево позволяет существенно сократить объём хранимых данных и ускорить навигацию по иерархии.

В **средах разработки** Radix Tree применяется для реализации автодополнения и поиска по словарю идентификаторов. Благодаря префиксной структуре возможен мгновенный поиск всех слов, начинающихся с заданной строки, даже при большом количестве таких слов.


## **Заключение**

Radix Tree и Patricia Trie являются эффективными структурами данных для работы с ключами, которые имеют общие префиксы. Radix Tree это универсальное решение для строковых данных, а Patricia Trie, является более специализированной и максимально сжатой структурой, которая применяется для двоичных ключей и в сетевой маршрутизации.

Обе структуры сохраняют линейную асимптотику операций по длине ключа, при этом сильно превосходят обычное префиксное дерево по производительности и по использованию памяти.

### **Использованные материалы:**


* [Википедия про Radix tree](https://en.wikipedia.org/wiki/Radix_tree)

* [Прикольная визуализация Radix tree](https://www.cs.usfca.edu/~galles/visualization/RadixTree.html)

* [Подробная статья про Radix tree](https://ankitpandeycu.medium.com/unleashing-the-potential-of-radix-tree-35e6c5d3b49d)

* [Подробная статья про Patricia Trie](https://medium.com/@aatreyimehta1/patricia-trie-85c65d5d206c)