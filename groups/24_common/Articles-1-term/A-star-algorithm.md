

## Введение

Алгоритм A star решает классическую задачу в теории графов: поиск кратчайшего пути в графе. В частности, данный алгоритм подходит для взвешенного графа с неотрицательными ребрами.
Задача поиска кратчайшего пути в графе возникает во многих областях жизни: навигация, робототехника, компьютерные игры, логистика. Для её решения существует множество алгоритмов, среди которых особое место занимает алгоритм **A***, так как он сочетает в себе гарантию оптимальности и высокую практическую эффективность.

Так как алгоритм A* тесно связан с алгоритмом Дейкстры, сначала поговорим про него.




## Алгоритм Дейкстры

### Основная идея и интуиция

Алгоритм Дейкстры находит кратчайшие расстояния от стартовой вершины до всех остальных. Его ключевая идея состоит в том, что, если все веса рёбер неотрицательны, то вершина с минимальным текущим расстоянием уже не может быть улучшена.
Интуитивно это можно понять так:
	Пусть мы стоим в вершинке $v$ и рассматриваем путь $v \rightarrow u$. Пусть для $u$ у нас уже известна минимальная стоимость, за которую мы можем до нее добраться. А теперь мы хотим "улучшить" эту стоимость, используя путь $v \rightarrow u$. Для этого мы просто складываем стоимость, за которую мы добрались до вершинки $v$, и вес ребра $v \rightarrow u$.
	Затем просто выполняем так называемую релаксацию ребра, то есть сравниваем текущую стоимость и найденную и выбираем лучшую.


### Более строго

Для каждой вершины хранится значение $dist[v]$ — текущее лучшее расстояние от старта.

Используется приоритетная очередь, реализованная, например, с помощью бинарной кучи, в которой вершины упорядочены по $dist$.

Алгоритм:

1. $dist[start] = 0$, для остальных вершин — inf;
    
2. пока очередь не пуста:
    
    - извлекается вершина с минимальным $dist$;
        
    - для каждого её соседа выполняется релаксация ребра.
        


### Релаксация рёбер

Рассматривается ребро $(v, u)$ с весом $w$.  
Если выполняется неравенство:

$dist[u]>dist[v]+w$

то расстояние до вершины $u$ обновляется.

Каждое ребро проверяется один раз, когда его начальная вершина извлекается из очереди.



### Асимптотика Дейкстры

Предположим, что:

- граф хранится в списках смежности,
    
- приоритетная очередь реализована бинарной кучей.
    

#### Операции алгоритма

1. **Извлечение минимума**  
	Используется бинарная куча (асимптотика ее работы здесь рассматриваться не будет).
    Выполняется один раз для каждой вершины — всего $|V|$ раз.  
    Стоимость одной операции — $O(log⁡|V|)$.
    
2. **Релаксация рёбер**  
    Каждое из $|E|$ рёбер проверяется один раз.  
    В худшем случае каждая релаксация приводит к обновлению положения вершины в куче, что стоит тоже $O(log⁡|V|)$.
    

Суммарная временная сложность:

$O(|V|\log{V}) + O(|E|\log{V}) = O((|V|+|E|)\log{V})$


Так как в связном графе $|E| \ge ∣V∣ − 1$ получаем итоговую сложность $O(∣E∣log⁡∣V∣)$:



## Связь алгоритма A* с алгоритмом Дейкстры

Простыми словами, алгоритм A* является улучшенной версией алгоритма Дейкстры.

Вместо сортировки вершин только по расстоянию от старта, A star использует функцию:

$$
f(v)=g(v)+h(v)
$$

где:

- $g(v)$ — расстояние от старта (как в Дейкстре),
    
- $h(v)$ — эвристическая оценка расстояния до цели.



## Интуиция

Эвристика — это приближённая оценка расстояния от текущей вершины до цели. 
Она используется как дополнительный параметр упорядочивания вершин в куче. 
В отличие от Дейкстры, в A* мы учитываем не только текущее пройденное расстояние, но и оценку расстояния до цели. Чтобы стало еще более понятно, представим, что
$h(v) = 0$ всегда. Тогда наш алгоритм превращается в самую обыкновенную Дейкстру. 

Очевидно, что эффективность работы алгоритма напрямую зависит от правильного выбора эвристики. Рассмотрим основные требования к ней.

### Требование к эвристике

1. Для сохранения оптимальности эвристика должна быть допустимой, то есть:

	$h(v) \leq h*(v)$

	где $h∗(v)$ — истинное кратчайшее расстояние до цели.
	
	Это означает, что эвристика может недооценивать расстояние, но не должна его переоценивать. 
	Если $h(v) > h*(v)$, то алгоритм теряет гарантию оптимальности, но часто находит путь быстрее. Это используется в задачах, где приемлем "хороший", но не обязательно идеальный путь (например, в некоторых играх). Такие вариации иногда называют "жадным" A* или Weighted A* (когда эвристика искусственно завышается на коэффициент).
2. $h(v) - h(u) \leq cost(v,u)$
	для любого ребра $(v,u)$.
	То есть мы не можем пройти по ребру 100 метров и стать на 200 метров ближе к цели.

Если оба условия соблюдаются, то эвристика называется допустимой.

## Теорема

>При использовании допустимых эвристик, алгоритм гарантировано найдет оптимальное решение.

Тут стоит отметить, что использование допустимых эвристик является достаточным условием, но не необходимым. То есть если использовать абы какую эвристику, алгоритм может найти верное решение, но это не точно.
Доказывать не будем.

#### Конструктивное доказательство 

1. Пусть найден путь длины С
    
2. Предположим, что существует путь короче С
    
3. Тогда на этом пути есть вершина v, для которой:
    $f(v) = g(v) + h(v) \leq C$
4. Но A* всегда выбирает минимальное f
    
5. Значит, такой путь был бы найден раньше $\implies$ противоречие, найденный путь оптимален


## Асимптотика алгоритма A*

Несмотря на то, что на практике, при правильном подборе эвристики, A* решает задачу намного эффективней и быстрее Дейкстры, строго математически асимптотика у них одинаковая, так как в худшем случае, при нулевой эвристике, A star эквивалентен Дейкстре и имеет сложность $O(|E|\log{|V|})$.


## Разные эвристики

Теперь рассмотри несколько эвристик.
1. Манхэттенская
	$|x_1​−x_2|+|y1_​−y_2|$
	Используется для 4 направлений
2. Евклидова 
	$\sqrt{(x_{1} - x_{2})^{2} + (y_{1} - y_{2})^2}$
	8-направленная
3. Чебышёвская
	$max(|dx|,|dy|)$
	Используется при одинаковых диагоналях


## Тонкости реализации

Здесь почти всё то же самое, что и в Дейкстре.
Используем два множества:
1. OPEN
	- приоритетная очередь (обычно куча),
	- содержит вершины, которые можно расширять
	- ключ — $f(v)$
    
2. CLOSED – здесь храним уже обработанные вершины


#### Пошаговый алгоритм 

1. Вставить $start$ в OPEN  
    $g(start) = 0, f(start) = h(start)$
    
2. Пока OPEN не пусто:
    - взять вершину $v$ с минимальным $f(v)$
    - если $v == goal$, завершить
    - перенести $v$ в CLOSED
    - для каждого соседа $u$:
        - если $u$ в CLOSED — пропустить
        - вычислить $g_{new} = g(v) + cost(v,u)$
        - если $u$ не в OPEN или $g_{new} < g(u)$:
            - обновить $g(u)$
            - $f(u) = g(u) + h(u)$
            - сохранить $parent(u) = v$
            - добавить $u$ в OPEN (обновить приоритет)

Ну и псевдокод какой-нибудь
```python
function A_Star(start, goal, h):
    openSet = PriorityQueue()  # Очередь с приоритетом по f
    openSet.put(start, 0)
    cameFrom = {}  # Для восстановления пути
    gScore = {node: inf for node in graph}  # Точная стоимость
    gScore[start] = 0
    fScore = {node: inf for node in graph}  # Оценочная стоимость
    fScore[start] = h(start, goal)

    while not openSet.empty():
        current = openSet.get()

        if current == goal:
            return reconstruct_path(cameFrom, current)

        for neighbor, cost in graph.neighbors(current):
            # Релаксация, как в Дейкстре
            tentative_gScore = gScore[current] + cost
            if tentative_gScore < gScore[neighbor]:
                # Этот путь до соседа лучше предыдущего
                cameFrom[neighbor] = current
                gScore[neighbor] = tentative_gScore
                fScore[neighbor] = gScore[neighbor] + h(neighbor, goal)
                if neighbor not in openSet:
                    openSet.put(neighbor, fScore[neighbor])
                # else: openSet.update_priority(neighbor, fScore[neighbor])
    return failure  # Путь не найден
```

## Когда использовать

Если коротко, то используйте A*, если нужно найти расстояние только до одной цели. Потому что если требуется узнать стоимость достижения всех целей, то, очевидно, что Дейкстра справится быстрее. Кроме того, A* хорошо использовать, если у вас есть хорошая и очевидная эвристическая функция, подходящая для конкретной задачи.

## Заключение

Алгоритм A* - это сочетание надежной теории и скорости в реальном мире, когда дело доходит до поиска кратчайшего маршрута. Он показывает, как использование умных предположений может действительно ускорить процесс, не теряя при этом гарантии нахождения наилучшего пути.

## Источники
https://www.redblobgames.com/pathfinding/a-star/introduction.html – самое адекватное интуитивное объяснение A*

https://en.wikipedia.org/wiki/A*_search_algorithm – сложнее, но содержательней

https://ru.wikipedia.org/wiki/Алгоритм_Дейкстры – здесь про Дейкстру хорошо

https://www.geeksforgeeks.org/artificial-intelligence/a-algorithm-and-its-heuristic-search-strategy-in-artificial-intelligence/ – про реализацию A* больше

