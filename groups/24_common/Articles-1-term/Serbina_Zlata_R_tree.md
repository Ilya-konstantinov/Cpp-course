
## **R-Дерево: Пространственная индексная структура для эффективного поиска**

---
Выполнила: Сербина Злата 11и2
### **Введение**

В современных приложениях, от геоинформационных систем (ГИС) и баз данных до игровых движков и систем анализа больших данных, часто возникает задача **пространственного поиска**. 
Решать такие задачи, перебирая и проверяя координаты всех объектов, крайне неэффективно при большом их количестве. Здесь на помощь приходят пространственные индексы, и одним из фундаментальных и самых известных среди них является **R-дерево** (Rectangle tree).

Я выбрала R-tree потому что оно красиво визуализируется и имеет широкое практическое использование.

### **Что такое R-дерево?**

**R-дерево** — это древовидная структура данных, предназначенная для индексации многомерной пространственной информации (например, географических координат, границ объектов на плоскости или в пространстве). Оно было предложено Антонином Гуттманом в 1984 году и стало основой для множества последующих разработок (R\*-дерево, R+-дерево, Hilbert R-дерево).

Ключевая идея R-дерева — **группировать близлежащие объекты и заключать их в минимальные ограничивающие прямоугольники (MBR — Minimum Bounding Rectangle)**. Эти прямоугольники, в свою очередь, также группируются и заключаются в прямоугольники более высокого уровня, формируя сбалансированное дерево.


<img width="613" height="648" alt="image" src="https://github.com/user-attachments/assets/6b22df49-1f26-4ba4-a954-025f2bf53307" />



### **Области применения**

*   **Геоинформационные системы (GIS):** Поиск объектов на карте, построение маршрутов.
*   **Пространственные базы данных:** Индексация геоданных в PostgreSQL/PostGIS, Oracle Spatial.
*   **Компьютерные игры и физические движки:** Определение коллизий, поиск объектов в зоне видимости.
*   **Многомерные базы данных:** Индексирование данных по нескольким измерениям.
*   **Файловые системы:** Организация метаданных о местоположении файлов на диске.

### **Мотивация использования 

-Пример проблемы-

Я очень люблю компьютерные игры, поэтому
На сервере игры есть сущности с данными:

- Координаты X и Y
- Массив указателей на игроков, которые находятся в зоне видимости этой сущности

Данные области видимости и "поля" для поиска:

- Размер поля в X и Y (2000x2000 у. е.)
- Размер стороны области видимости

Область видимости, в данном случае - это квадрат с равными сторонами, которые указаны в данных выше. Сущность, к которой применяется поиск, находится в центре этого квадрата.  
  
Синхронизация в логике Go(на котором сделан сервер) обновляется раз в секунду.
У следующих сущностей будут случайно сгенерированная позиция в пределах поля.

Теперь к самим показателям, начнем с **квадратичного линейного поиска**:

|   |   |   |
|---|---|---|
|Количество сущностей, единиц|Область видимости, у. е.|Время обновления стриминга для всех игроков, мсек|
|1000|200|72.5|
|2000|200|295|
|4000|100|1150|

С учетом того, что синхронизация обновляется раз в секунду, мы можем понять, что при показателях в **4000** сущностей сервер просто перестанет нам отвечать, если все данные обрабатываются в одном потоке или если есть обращение к этой структуре...
  
Но с использованием R-tree результаты улучшаются в десятки раз:

|   |   |   |
|---|---|---|
|Количество сущностей, единиц|Область видимости, у. е.|Время обновления стриминга для всех игроков, мсек|
|1000|200|16|
|2000|200|55|
|4000|100|110|

Очевидно, использование R-tree помогает ускорить работу игры.
### **Как устроено R-дерево?**




1.  **Узлы и листья:**
    *   **Листья** содержат записи (пространственные объекты или ссылки на них). Каждая запись в листе хранит собственные координаты объекта и его MBR.
    *   **Внутренние узлы** содержат дочерние MBR и ссылки на дочерние узлы. Каждый дочерний MBR полностью охватывает все MBR объектов в поддереве.

2.  **Свойства:**
    *  Все листья находятся на одной глубине.
    *   Корень дерева содержит MBR, который покрывает все объекты в индексе (а не всё пространство вообще)
    *   **Параметры:** `M` — максимальное количество записей в узле, `m` — минимальное (обычно `m ≤ M/2`). Эти параметры влияют на форму дерева и его производительность.

3.  **Пример структуры:**
    Как карта города. Все здания (точечные объекты) группируются в районы (прямоугольники-листья). Районы группируются в округа (прямоугольники более высокого уровня), а округа — в весь город (прямоугольник корня).

### **Основные операции**

#### **1. Поиск (Search)**
Задача: найти все объекты, чьи MBR пересекаются с заданным поисковым прямоугольником (или точкой).
*   **Алгоритм:** Начинаем с корня. Для каждого дочернего MBR в узле проверяем, **пересекается** ли он с поисковым прямоугольником.
    *   Если нет — всё поддерево игнорируется (это ключевая оптимизация, отсекающая большие области).
    *   Если да — рекурсивно продолжаем поиск в соответствующем дочернем узле.
    *   Достигнув листа, добавляем объекты, удовлетворяющие условию, в результат.

#### **2. Вставка (Insert)**
*   **Алгоритм:**
    1.  **Выбор листа:** Спускаемся от корня, на каждом уровне выбирая дочерний узел, MBR которого потребует **наименьшего расширения** для включения нового объекта (эвристика минимизации площади).
    2.  **Добавление в лист:** Если в выбранном листе есть свободное место (`< M` записей), добавляем объект и расширяем MBR листа (и всех его предков при необходимости).
    3.  **Разделение узла (Split):** Если лист переполнен, его необходимо разделить на два узла. Это **самая сложная часть алгоритма**. Задача — разбить `M+1` объектов на две группы так, чтобы суммарная площадь их новых MBR была минимальна (чтобы уменьшить перекрытие и улучшить производительность поиска). Существует несколько алгоритмов разделения (линейный, квадратичный, экспоненциальный).
    **Теоретическая сложность** вставки в R-дерево — **O(log n)**, где n — общее количество узлов. Здесь стоит отметить, что в худшем случае сложность может быть O(N)

#### **3. Удаление (Delete)**
1.  Находим лист, содержащий объект, и удаляем его.
2.  Если в листе осталось меньше `m` записей, узел ликвидируется, а его записи повторно вставляются в дерево (reinsert). Иногда это лучше, чем немедленное слияние, и помогает перебалансировать дерево.

### **Плюсы и минусы R-дерева**

**Преимущества:**
*   **Высокая эффективность поиска:** В среднем сложность поиска — O(logᴍ N), где N — количество объектов. Это намного лучше линейного перебора O(N).
*   **Универсальность:** Работает с объектами любой формы (через их MBR) и в многомерном пространстве.
*   **Динамичность:** Эффективно поддерживает вставку и удаление данных без полной перестройки индекса.
*   **Широкая поддержка:** Реализовано в большинстве СУБД (PostgreSQL/PostGIS, MySQL, Oracle), GIS-библиотеках и специализированных движках.

**Недостатки и проблемы:**
*   **Перекрытие MBR:** Прямоугольники узлов на одном уровне могут пересекаться. Это главный недостаток, так как при поиске может потребоваться спуск по нескольким ветвям дерева, что снижает производительность.
*   **Зависимость от порядка вставки:** Последовательность добавления данных влияет на форму дерева и его эффективность.
*   **Сложность алгоритмов разделения:** Качество дерева сильно зависит от выбранной эвристики при разделении узлов.

### **Улучшенные варианты: R * -дерево**

Для борьбы с ключевыми проблемами классического R-дерева был разработан **R * -дерево**. Его основные усовершенствования:
1.  **Улучшенная эвристика вставки:** Минимизирует не только площадь, но и периметр MBR, а также перекрытие с соседними MBR.
2.  **Принудительная перезапись (Forced Reinsert):** При переполнении узла часть его записей извлекается и вставляется заново на более высоком уровне. Это действует как динамическая перебалансировка и часто приводит к более качественным деревьям с меньшим перекрытием.
R*-дерево на практике почти всегда превосходит классическое R-дерево по скорости поиска и стало де-факто стандартом в реализациях.

Все данные остаются теми же самыми, но мы буквально можем заметить визуальные отличия:

1. Поддеревья и ветки располагаются так, чтобы не накладываться друг на друга. Уменьшается перекрытие веток.
2. Все ветки или поддеревья стараются быть минимальных размеров. Уменьшается площадь листьев и веток.

Как раз, в этом и есть главная задумка ** R * -tree**!  
  
При абсолютно каждой вставке элемента происходит цикл, который перебирая все возможные элементы, старается уменьшить площадь веток и перекрытие веток, таким образом, упрощая в будущем поиск по этой структуре данных!  
  
Как мы понимаем, за счет таких манипуляций, растёт и цена (то есть, время) вставки элемента. Причем, если дерево становится больше, то и элементов нужно перебирать больше.

### **Заключение**

R-дерево — это краеугольный камень в мире пространственных индексов. Его улучшенные версии, такие как R*-дерево, продолжают оставаться одним из основных инструментов для работы с пространственными данными, где требуется быстрый поиск по региону. Понимание принципов работы R-дерева открывает путь к освоению более сложных пространственных и многомерных структур данных.

### **Использованные материалы:**

https://habr.com/ru/articles/666904/ - статья о применении в мультиплеерах, сравнение R-tree c R*-tree
https://www.bartoszsypytkowski.com/r-tree/ - пример реализации 
https://en.wikipedia.org/wiki/R-tree - вики
https://ru.ruwiki.ru/wiki/R-дерево_(структура_данных) - очень подробное описание реализации
