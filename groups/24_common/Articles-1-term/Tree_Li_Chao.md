# Творческая 

## Структура данных "Дерево Ли Чао"

Дерево Ли Чао (Li Chao Tree) — это структура данных для эффективного хранения и 
запроса набора линейных функций (типа \(f(x)=ax+b\)) для 
нахождения максимального/минимального значения \(f(x)\) в заданной точке \(x\).

Эта структура может обрабатывать два вида запросов:
1. Добавить линейную функцию f(x) = ax + b в множество X
2. Найти экстремумы f(x) по всем f ∈ X при заданном x.

Как работает и что вообще строим:
### 0. Что мы вообще строим
   Мы строим бинарное дерево по оси X, где:
   - каждый узел отвечает за диапазон x
   - в каждом узле хранится ровно одна прямая
   - эта прямая лучшая (max) в середине диапазона
   - при запросе мы идём по одному пути и считаем значения всех прямых на этом пути

### 1. Что хранит структура (данные)
#### 1.1 Прямая
> f(x) = a * x + b
```
class Line { 
    long a, b; 
    long value(long x) {
        return a * x + b;
    }
}
```
#### 1.2 Узел дерева

Каждый узел:
- отвечает за диапазон [l, r] (НЕ хранится явно, передаётся в рекурсии)
- хранит одну прямую
- имеет двух детей

  ```
  class Node {
        Line line;     // одна прямая
        Node left;     // левый ребёнок
        Node right;    // правый ребёнок
    }
  ```

### 2. Главная идея. Реализация добавления прямой в структуру
> В каждом узле хранится прямая, которая является максимальной в середине диапазона этого узла

Если узел отвечает за <code>[l, r]</code>, то:
<code> m = (l + r) / 2 </code>
и <code>node.line(m)</code> — максимум среди всех линий, которые когда-либо попадали в этот узел.

### Исходная ситуация:
Мы находимся в вершине дерева, которая отвечает за диапазон: [l,r]

В этой вершине есть:
- старая прямая f(x)
- новая прямая g(x)

Нужно решить:
1. какую прямую оставить в этой вершине
2. куда (и нужно ли) проталкивать вторую

<b> Шаг 1 </b>

Находим середину (середину диапазона): 
<code> m = (l + r) / 2  </code> 

<b> Шаг 2 </b> <p>
Сравниваем значения прямых <b> в середине </b>

Мы считаем: <code> f(m) и g(m) </code>

#### Зачем именно середина?
Потому что инвариант дерева такой:

> В каждой вершине хранится прямая, оптимальная в середине её диапазона

Что делаем по результату?
Если ищем минимум:
- Если <code> g(m) < f(m) </code> → меняем их местами

Теперь:
- в вершине лежит лучшая в точке m прямая
- в переменной g — проигравшая


<b> Шаг 3. Проверяем, где проигравшая может быть полезной </b>

Теперь в вершине:
- best — прямая, лучшая в m
- bad — проигравшая

Но bad может быть лучше на части диапазона.

Чтобы понять где — сравниваем значения на концах диапазона.

<b> Шаг 4. Сравнение на концах диапазона </b>

Сравниваем:
- bad(l) и best(l)
- bad(r) и best(r)

Возможные случаи:
1. bad(l) < best(l)
    - значит, слева bad лучше
    - возможное пересечение в левой половине
    - проталкиваем bad в левого сына
2. bad(r) < best(r)
    - значит, справа bad лучше
    - пересечение в правой половине
    - проталкиваем bad в правого сына
3. Ни то, ни другое
    - bad хуже на всём [l, r]
    - она никогда не будет ответом
    - её можно выбросить 

<b> Почему этого достаточно </b>

Потому что:
- любые две прямые пересекаются не более одного раза
- значит, bad может быть лучше только в одном непрерывном куске
- сравнения в l, m, r позволяют определить, где этот кусок

> Упрощённый вариант <p>
    На практике часто делают так: <p>
    1. Сравнили в m → выбрали лучшую <p>
    2. Сравнили только в одном конце:
        - если bad(l) < best(l) → влево
        - иначе → вправо <p>
    Потому что второй вариант автоматически следует из первого.


### Доказательство ассимптотики

Будем доказывать, что:
> Добавление одной прямой в дерево Ли Чао работает за O(log X)
(где X — размер диапазона координат x)

1. Что происходит при добавлении прямой

Алгоритм добавления:
1. Начинается в корне дерева (диапазон [L, R])
2. В каждой вершине:
   - выполняется константное число операций
   - выбирается одно поддерево
   
3. Рекурсивно спускается вниз
4. Завершается либо:
   - при достижении листа
   - либо когда прямая перестаёт конкурировать

<b> Важно </b>: на каждом шаге выбирается только один потомок, а не оба.

2. Высота дерева Ли Чао

   Дерево Ли Чао — это обычное дерево отрезков по оси x.
   <p> Если диапазон: [X min, X max]
   <p> то глубина дерева равна: h = O(log(X max - X min) 
   <p> или просто: h = O(logX)


3. Лемма: на каждом уровне — O(1) работы

В одной вершине мы выполняем:
- вычисление значений двух функций в 2–3 точках
- несколько сравнений
- возможно swap
- один переход в поддерево

Это всё — константное время: O(1)

4. Лемма: алгоритм спускается только в одно поддерево 

    На каждом уровне:
    - мы сравниваем прямые 
   - доказываем, что проигравшая прямая может быть оптимальной только в одной половине
   - поэтому рекурсия идёт либо влево, либо вправо

<b> Никогда не происходит ветвления в оба поддерева </b>

5. Лемма: глубина рекурсии ограничена высотой дерева

Так как:
- на каждом шаге мы спускаемся ровно на 1 уровень
- максимальная глубина — O(log X)

то максимальное число рекурсивных вызовов: O(logX)

6. Объединение лемм

   Общее время добавления прямой:

    <b> время = O(1) * O(logX) = O(logX)</b>

#### Ключевое свойство (почему вообще всё работает)
Алгоритм опирается на свойство:
> Любые две функции пересекаются не более чем в одной точке

Из-за этого:
- проигравшая прямая может быть лучше только в одной половине
- мы не обязаны рассматривать обе

Если бы пересечений было больше — алгоритм сломался бы.

### Итоговое доказательство (коротко)
При добавлении новой прямой алгоритм:
- делает O(1) работы в каждой вершине
- спускается только в одно поддерево
- глубина дерева равна O(log X)

<b> Следовательно, время добавления одной прямой равно
O(logX) </b>