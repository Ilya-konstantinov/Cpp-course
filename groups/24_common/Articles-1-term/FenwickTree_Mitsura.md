# «Дерево Фенвика»

**Выполнила:** Мицура Анастасия 11и2 

## 1. Введение

Дерево Фенвика (Binary Indexed Tree, BIT) - структура данных, предложенная Питером Фенвиком в 1994 году. Она решает задачу эффективного выполнения двух операций над массивом: вычисления суммы на отрезке и обновления элемента. Классическое решение с массивом частичных сумм дает быстрое вычисление суммы за O(1), но медленное обновление за O(N). Дерево Фенвика выполняет обе операции за O(log N), используя O(N) памяти.

## 2. Принцип работы

### 2.1. Основные определения

Пусть имеется массив a[0..N-1]. Дерево Фенвика реализуется массивом tree[0..N-1], где каждый элемент tree[i] хранит сумму элементов исходного массива на отрезке [F(i), i], где:

```
F(i) = i & (i + 1)
```

Здесь `&` - побитовая операция И.

### 2.2. Пример

- Для i = 5 (двоичное 101): F(5) = 5 & 6 = 101₂ & 110₂ = 100₂ = 4
  
  tree[5] = a[4] + a[5]

- Для i = 7 (двоичное 111): F(7) = 7 & 8 = 111₂ & 1000₂ = 0000₂ = 0
  
  tree[7] = a[0] + a[1] + ... + a[7]

## 3. Алгоритмы и асимптотика

### 3.1. Вычисление суммы префикса

Алгоритм вычисления суммы a[0] + a[1] + ... + a[r]:

```python
class FenwickTree:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)
    
    def sum(self, r):
        """Сумма на префиксе [0..r]"""
        res = 0
        i = r + 1  # переход на 1-индексацию
        while i > 0:
            res += self.tree[i]
            i -= i & -i  # i & -i находит младший значащий бит
        return res
    
    def range_sum(self, l, r):
        """Сумма на отрезке [l..r]"""
        return self.sum(r) - self.sum(l - 1)
```

**Доказательство сложности O(log N):** Операция i -= i & -i на каждом шаге обнуляет младший значащий бит числа i. В худшем случае потребуется log₂ N операций.

### 3.2. Обновление элемента

Алгоритм увеличения элемента a[pos] на величину delta:

```python
    def update(self, pos, delta):
        """Увеличить a[pos] на delta"""
        i = pos + 1  # переход на 1-индексацию
        while i <= self.n:
            self.tree[i] += delta
            i += i & -i  # переход к следующему элементу
```

**Доказательство сложности O(log N):** Операция i += i & -i на каждом шаге добавляет единицу к младшему значащему биту. Максимальное количество шагов - log₂ N.

### 3.3. Полная реализация с примером

```python
class FenwickTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (self.n + 1)
        # Построение дерева
        for i in range(self.n):
            self.update(i, arr[i])
    
    def sum(self, r):
        res = 0
        i = r + 1
        while i > 0:
            res += self.tree[i]
            i -= i & -i
        return res
    
    def range_sum(self, l, r):
        return self.sum(r) - self.sum(l - 1)
    
    def update(self, pos, delta):
        i = pos + 1
        while i <= self.n:
            self.tree[i] += delta
            i += i & -i

# Пример использования
if __name__ == "__main__":
    arr = [1, 3, 2, 5, 4, 6]
    ft = FenwickTree(arr)
    
    print("Исходный массив:", arr)
    print("Сумма на [0..3]:", ft.range_sum(0, 3))  # 1+3+2+5 = 11
    print("Сумма на [2..5]:", ft.range_sum(2, 5))  # 2+5+4+6 = 17
    
    # Обновление элемента
    ft.update(2, 3)  # Увеличиваем a[2] на 3 (было 2, стало 5)
    print("\nПосле обновления a[2] += 3:")
    print("Новая сумма на [0..3]:", ft.range_sum(0, 3))  # 1+3+5+5 = 14
```

## 4. Сравнение с деревом отрезков

| Критерий | Дерево Фенвика | Дерево отрезков |
|----------|----------------|-----------------|
| **Сложность операций** | O(log N) | O(log N) |
| **Объем памяти** | **O(N)** (точно N+1) | O(4N) в наивной реализации |
| **Константа времени** | **Меньшая** (простые циклы, битовые операции) | Большая (рекурсия, передача границ) |
| **Простота реализации** | **Предельно проста** (15-20 строк) | Относительно сложна (50+ строк) |
| **Функциональность** | **Специализирована:** только RSQ и модификация точки | **Универсальна:** поддерживает сумму, min/max, gcd, отложенные обновления |
| **Требования к операции** | Должна быть **обратимой** (сумма — да, min — нет) | Любая ассоциативная операция |


### 4.1. Преимущества дерева Фенвика

1. **Простота реализации** (15-20 строк кода против 50+ у дерева отрезков)
2. **Меньшая константа в асимптотике** благодаря использованию битовых операций
3. **Экономия памяти** (N элементов против 4N у дерева отрезков)
4. **Высокая скорость на практике**

### 4.2. Недостатки дерева Фенвика

1. **Ограниченная применимость** (только обратимые операции)
2. **Не поддерживает минимум/максимум** без модификаций
3. **Менее интуитивное понимание** по сравнению с деревом отрезков

## 5. Практическое применение

Дерево Фенвика используется в следующих задачах:

1. **Подсчет инверсий в массиве** - классическая задача, решаемая с помощью BIT
2. **Обработка запросов в статических и динамических массивах**
3. **Реализация алгоритма Мо** при определенных условиях
4. **Двумерные варианты** для работы с матрицами (2D BIT)
5. **Задачи на частотные таблицы** - изначальная область применения Фенвика

## 6. Заключение

Дерево Фенвика - эффективная структура данных для задач с запросами суммы на отрезке и точечными обновлениями. Его простота реализации, высокая производительность и экономичное использование памяти делают его предпочтительным выбором там, где его функциональности достаточно.
