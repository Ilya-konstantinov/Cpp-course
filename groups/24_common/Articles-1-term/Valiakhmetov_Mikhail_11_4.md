# **Суффиксный массив**

Выполнил: Валиахметов Михаил  
Класс: 11и4

### **Введение**

При работе со строками в программировании часто возникают задачи поиска подстрок, анализа текста, сравнения строк и нахождения повторяющихся фрагментов.
Если решать такие задачи наивно, например, сравнивая подстроку с каждой позицией строки, то алгоритмы начинают работать слишком медленно уже при больших размерах входных данных.
Поэтому в программировании были разработаны специальные строковые структуры данных. Одной из самых важных и универсальных является **суффиксный массив**.

### **Что такое суффиксный массив?**

**Суффиксный массив** — это массив индексов всех суффиксов строки, отсортированных в лексикографическом порядке.

Пусть дана строка `s` длины `n`.
**Суффикс** строки с позиции `i` — это подстрока `s[i..n-1]`.

Суффиксный массив `SA` — это такой массив длины `n`, что:

```
s[SA[0]..] < s[SA[1]..] < ... < s[SA[n-1]..]
```

**Пример**

Строка: `s = "abab"`

Суффиксы:

* 0: abab
* 1: bab
* 2: ab
* 3: b

После сортировки:

* ab (2)
* abab (0)
* b (3)
* bab (1)

Суффиксный массив:

```
SA = [2, 0, 3, 1]
```

### **Области применения**

* Поиск подстрок в тексте
* Подсчет количества различных подстрок
* Поиск самой длинной повторяющейся подстроки
* Сравнение подстрок
* Анализ ДНК и биоинформатика

### **Мотивация использования**

**Пример проблемы**

Пусть дан текст длины `n = 1 000 000` символов.
Нужно определить, встречается ли в нем подстрока длины `m`.

Наивный алгоритм:

* перебирает все позиции,
* сравнивает до `m` символов,
* сложность `O(n·m)`.

При больших `n` это слишком медленно.

Но если построить суффиксный массив:

* все суффиксы уже отсортированы,
* поиск подстроки выполняется бинарным поиском,
* сложность поиска `O(m log n)`.

Таким образом, суффиксный массив ускоряет работу со строками.

### **Как устроен суффиксный массив**

Суффиксный массив — это обычный массив чисел, но важен способ его построения.

На практике чаще всего используется **метод удвоения**, который строит массив за `O(n log n)`.

#### **Идея метода удвоения**

1. Сначала сортируем суффиксы по первым `2⁰ = 1` символу.
2. Затем по первым `2¹ = 2` символам.
3. Потом по `2² = 4`, `2³ = 8` и так далее.
4. На каждом шаге длина учитываемого префикса удваивается.

На каждом этапе каждому суффиксу присваивается **класс эквивалентности** — его ранг среди других суффиксов.

### **Основные операции**

#### **1. Построение суффиксного массива**

На шаге `k` каждый суффикс описывается парой:

```
(c[i], c[i + 2ᵏ])
```

где `c[i]` — класс эквивалентности по первым `2ᵏ` символам.

Такие пары сортируются с помощью сортировки подсчетом, так как значения классов находятся в диапазоне от `0` до `n-1`.

### **Доказательство асимптотики построения O(n log n)**

#### **1. Количество шагов**

На каждом шаге длина префикса удваивается:

```
1, 2, 4, 8, ..., 2ᵏ
```

Алгоритм завершается, когда:

```
2ᵏ ≥ n
```

Отсюда:

```
k ≥ log₂ n
```

Следовательно, количество шагов равно **O(log n)**.

#### **2. Стоимость одного шага**

На каждом шаге:

* сортируются `n` суффиксов,
* сортировка подсчетом работает за `O(n)`,
* пересчет классов также занимает `O(n)`.

Итак, один шаг выполняется за **O(n)**.

#### **3. Итоговая сложность**

Количество шагов: `O(log n)`
Стоимость одного шага: `O(n)`

Общая сложность:

```
O(n) · O(log n) = O(n log n)
```

**Следовательно, суффиксный массив строится за O(n log n).**

### **LCP-массив и его асимптотика**

Часто вместе с суффиксным массивом строят **LCP-массив** (Longest Common Prefix).

`LCP[i]` — длина общего префикса суффиксов `SA[i]` и `SA[i−1]`.

Для его построения используется **алгоритм Касаи**.

### **Доказательство сложности LCP = O(n)**

Алгоритм поддерживает переменную `k` — текущую длину совпадения.

Важно, что:

* `k` увеличивается только при сравнении одинаковых символов,
* при переходе к следующему суффиксу `k` уменьшается максимум на 1.

За весь алгоритм:

* `k` может увеличиться не более чем на `n`,
* уменьшиться тоже не более чем на `n`.

Следовательно, суммарное число сравнений символов линейное, то есть **O(n)**.

### **Плюсы и минусы суффиксного массива**

**Преимущества:**

* Эффективная работа со строками
* Меньше памяти, чем у суффиксного дерева
* Строго доказанная асимптотика
* Подходит для олимпиадных задач

### **Заключение**

Суффиксный массив — это универсальная структура данных для обработки строк.
Он позволяет эффективно решать задачи поиска и анализа текста.
Метод удвоения обеспечивает построение за `O(n log n)`, а LCP-массив строится за `O(n)`.
Благодаря строгим доказательствам сложности суффиксный массив широко применяется как в теории, так и на практике.

### **Источники**

1. https://youtu.be/IB2VHT1zTUE?si=7S_Les9f55JSw4gW  
2. https://youtu.be/Wa48ST0jZ1Q?si=rMrlaHhsXltQU4G-  
3. https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D1%83%D1%84%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2  
4. https://ru.algorithmica.org/cs/string-structures/suffix-array/
