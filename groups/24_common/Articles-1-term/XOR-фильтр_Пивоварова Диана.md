
# Xor-фильтр: эффективная структура данных для принадлежности множеству**

Выполнила: Пивоварова Диана 11И1
## Введение

Представьте, что вы — администратор огромной онлайн-игры. У вас есть список из миллиона запрещённых ников. Игрок создаёт новый ник, и вам нужно мгновенно проверить, нет ли его в чёрном списке.

Проблема:
- Хранить весь список в оперативной памяти — дорого.
- Искать по всему списку каждый раз — медленно.

XOR-фильтр — одно из самых быстрых и экономных решений.

## Что такое XOR-фильтр?

**XOR-фильтр** — это компактная структура данных, которая почти не занимает места в памяти и быстро проверяет, точно ли какого-то элемента нет в нашем исходном наборе данных.

**Ключевая особенность:** Он никогда не врёт, говоря «нет». Если фильтр сказал: «Этого элемента у меня нет» — значит, его и правда нет в исходном списке. Но если он говорит: «Возможно, есть» — нужно перепроверить по основному (большому) списку. Он фильтрует заведомо лишние запросы.

**Как это выглядит технически?**

- У нас есть массив (коробка с ячейками). В каждой ячейке лежит какое-то число.
- У нас есть три функции (как три подсказки), которые для любого элемента говорят, в какие три ячейки массива нужно посмотреть.
- Мы складываем числа из этих трёх ячеек особым способом (с помощью операции XOR) и получаем ключ.
- Если этот ключ совпадает с «отпечатком» нашего элемента — фильтр говорит «возможно, есть». Если не совпадает — он говорит «точно нет».

## Алгоритм построения фильтра

**1. Подготовка**

- Выбираем три хеш-функции: h1(x), h2(x), h3(x). Они для любого элемента будут выдавать три случайных, но всегда одинаковых для этого элемента числа. Это будут номера ящиков в нашей коробке.
- Выбираем функцию отпечатка (fingerprint): f(x). Она превращает элемент в небольшое число (скажем, 32 бита) — его «цифровой код» или «отпечаток».
- Создаём пустой массив F длиной m. Длина m выбирается примерно m ≈ 1.23 * n (на 23% больше числа элементов). Все ячейки изначально заполнены нулями.

**2. Создание «графа зависимостей»**

Это ключевой этап. Мы должны разложить «отпечатки» элементов по ячейкам массива так, чтобы для каждого элемента x выполнялось главное уравнение:

`F[h1(x)] XOR F[h2(x)] XOR F[h3(x)] = f(x)`
(Отпечаток элемента = XOR трёх ячеек, на которые указывают его хеши)

**Как этого добиться?:**

- Строим граф. Каждую ячейку массива представляем как вершину графа. Каждый элемент x — это ребро, соединяющее три вершины h1(x), h2(x), h3(x). На это ребро мы вешаем вес, равный отпечатку f(x).
- Находим висячие рёбра. Ищем в графе вершину, которая соединена только с одним ребром. Такое бывает, потому что рёбер (элементов) меньше, чем вершин (ячеек массива).
- Распутываем граф. Берём висячее ребро (элемент x). Мы можем однозначно вычислить, какое число должно быть в свободной вершине (ячейке), чтобы уравнение для x выполнилось. Допустим, две другие ячейки уже заполнены (или пока нули). 
`Тогда: F[свободная_ячейка] = f(x) XOR F[ячейка1] XOR F[ячейка2]`
После этого мы удаляем это ребро из графа.
- Повторяем. После удаления ребра у других вершин может уменьшиться количество связанных рёбер, и они станут висячими. Мы повторяем процесс, пока не удалим все рёбра (все элементы).

*Важно: Этот алгоритм («peeling process» — процесс обдирания) работает, только если граф не имеет сложных циклов. Если он зациклился, мы можем просто выбрать другие три хеш-функции и начать заново. На практике это происходит быстро.*

**3. Заполнение массива**

В итоге у нас есть значения для всех ячеек массива F. Эти значения подобраны так, что для каждого исходного элемента главное уравнение выполняется.

## Алгоритм запроса (проверка элемента)

- Вычисляем индексы. Находим три номера ящиков для y с помощью тех же хеш-функций:
  `i1 = h1(y), i2 = h2(y), i3 = h3(y)`
- Достаём значения из массива. Идём к массиву F и считываем три числа:
  `v1 = F[i1], v2 = F[i2], v3 = F[i3]`
- Вычисляем XOR. Складываем эти три числа через операцию XOR:
  `result = v1 XOR v2 XOR v3`
- Вычисляем отпечаток y:
  `fp = f(y)`
- Сравниваем:
  `Если result == fp → фильтр говорит: «Возможно, элемент есть» (может быть ложное срабатывание)`
  `Если result != fp → фильтр говорит: «Элемента точно нет!» (ложных отрицаний не бывает)`

## Почему это работает?

- Для всех элементов из исходного набора мы специально подобрали значения в массиве, чтобы уравнение выполнялось. Поэтому для них фильтр всегда скажет «возможно, есть».
- Для постороннего элемента три ячейки массива хранят числа, которые мы не подбирали специально для него. Шанс, что их XOR случайно совпадёт с отпечатком этого нового элемента, очень мал (определяется битностью отпечатка, например, 1 из 4 миллиардов для 32 бит). Это и есть вероятность ложного срабатывания.

## Асимптотика

**- Время проверки (поиска) одного элемента: O(1).**
**- Память, которую он занимает: O(n), где n — количество элементов в исходном наборе.**

*O(1)*
Неважно, у вас 1000 элементов или 1 000 000 — проверка займёт одно и то же, фиксированное число операций (всего несколько вычислений и доступов к памяти).

*O(n)*
Это значит, что память растёт пропорционально числу элементов. Если для 1 элемента нужно ~10 байт, то для 1 000 000 элементов нужно ~10 000 000 байт. Для сравнения, хеш-таблица для той же задачи может занять в 2-3 раза больше места.

## Доказательство асимптотики

**Почему поиск за O(1)**

*Чтобы проверить элемент, нам нужно:*

- Вычислить 3 хеш-функции для него. Хорошие хеш-функции работают за O(1) — они просто делают фиксированное число вычислений над битами элемента.
- Взять 3 значения из массива по полученным индексам. Взять значение из массива по индексу — это тоже O(1).
- Выполнить две операции XOR (⊕) между этими значениями. Это фиксированное число операций.

Итого: Фиксированное число шагов, ни один из которых не зависит от общего числа элементов n. Значит, общее время константное, то есть O(1).

**Почему память O(n)?**

- Размер массива внутри фильтра пропорционален числу элементов n. Конкретно, обычно массив имеет длину примерно 1.23 * n.
- В каждой ячейке лежит число фиксированного размера.

Итого: Память = (примерно 1.23 * n) * 4 байта. Это формула вида C * n, где C — константа. А в асимптотике C * n — это и есть O(n) (константу C мы отбрасываем, нас интересует только тип роста).

*Самое сложное* — построение фильтра.
Cоздать (построить) XOR-фильтр для набора данных — задача посложнее (O(n) по времени, но с большей константой). Нужно так подобрать числа для ячеек массива, чтобы для каждого исходного элемента его «отпечаток» получался именно из XOR трёх соответствующих ячеек. Но это делается один раз, когда список создаётся, а проверяться он будет миллионы раз, где и проявляется его суперсила O(1).

## Заключение

XOR-фильтр — это инструмент, который жертвует маленькой долей точности (иногда говорит «возможно, есть», когда на самом деле нет) ради экономии памяти и мгновенной скорости проверки.

**Его главные преимущества:**

- Невероятно быстрый поиск (O(1)).
- Маленькие затраты памяти (~1.23n * размер_числа).
- Никогда не пропускает «плохие» элементы (ложно-отрицательных ответов нет).

Он хорошо подходит для задач, где данные читаются часто, а меняются редко: чёрные списки, кэши, системы хранения (например, проверка, есть ли файл в архиве), базы данных.

## Источники

<https://habr.com/ru/articles/673776/>

<https://habr.com/ru/companies/wunderfund/articles/936354/>

