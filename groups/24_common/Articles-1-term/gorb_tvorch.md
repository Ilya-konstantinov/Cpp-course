# Дерево ван Эмде Боаса

---

## 1. Общая идея

---

**Дерево ван Эмде Боаса** - дерево поиска, позволяющее хранить целые неотрицательные числа в интервале $[0;2k)$, где k - число бит из которых состоит число. Основная особенность этого дерева это выполнение почти всех операций за $O(log(k))$.
![alt text](image-1.png)
На рисунке показан пример такого дерева при k=4.

---

## 2. Обозначения

---

Будем использовать следующие обозначения:
*   k - число бит в числе, равное степени двойки
*   mini - минимальное число в дереве
*   aux - вспомогательное k/2 дерево
*   maxi - максимальное число в дереве

---

## 3. Структура

---
Как уже было сказано выше k-дерево хранит числа в интервале $[0;2k)$. Тогда при k=1 дерево будет хранить информацию о том есть ли в нем 1 или 0.

Теперь разберем дерево при $k \neq 1$:
* массив ___*children*___, состоящий из $2^{k/2} k/2 деревьев.$
* вспомогательное дерево aux
* maxi и mini

Представим, что у нас есть k-битное число x. Число из первых k/2 бит назовем **high(x)**, вторую половину назовем **low(x)**. Тогда операция проверки числа на принадежность равна проверке нахождения **low** в *children[high]*.

Можно заметить, что высота дерева равна $\log_{2}{k}$, потому что каждый следующий уровень дерева будет содержать числа составленные из числа бит в 2 раза меньшего.

В вспомогательном дереве *aux* будем хранить все такие числа *p*, что дерево *children[p]* не будет пустым.

---

## 4. Основные операции

---

Теперь перейдем к разбору базовых функций в этом дереве.

---

### 4.1 Поиск минимума и максимума в дереве
    
Так как мы храним минимум и максимум, то данные операции будут выполнены за *O(1)*.

---

### 4.2 Алгоритм вставки числа в дерево (*insert*)

    insert(T, x):
    if T.is_empty():
        T.min = T.max = x
    else:
        if x < T.min:
            swap(x, T.min) # мы не храним минимум в поддеревьях, придется вставить старый минимум
        if x > T.max:
            T.max = x
        if T.k != 1: # если это 1-дерево, то не имеет смысла дальше что-то пропихивать
            if T.children[high(x)].is_empty():
                insert(T.aux, high(x)) # если так, то следующий insert выполнится за O(1)
            insert(T.children[high(x)], low(x))

Асимптотика работы такого алгоритма *O(log(k))*

---

### 4.3 Функция поиска

---

    find(T, x):
    if T.is_empty():
        return False
    else if T.min == x or T.max == x:
        return True
    else:
        return find(T.children[high(x)], low(x))

Асимптотика работы такого алгоритма *O(log(k))*

---

### 4.4 Поиск следующего ближайшего к x числа в дереве

---
Алгоритм нахождения следующего элемента, как и два предыдущих, сводится к рассмотрению случая, когда дерево содержит не более одного элемента, либо к поиску в одном из его поддеревьев:

* если дерево пусто, или максимум этого дерева не превосходит x, то следующего элемента в этом дереве не существует.
* если x меньше поля min, то искомый элемент и есть min.
* если дерево содержит не более двух элементов, и x< max, то искомый элемент max.
* если же в дереве более двух элементов, то:
    * если в дереве есть еще числа, большие x, и чьи старшие биты равны high(x), то продолжим поиск в поддереве children[high(x)], где будем искать число, следующее после low(x).
    * иначе искомым элементом является либо минимум следующего непустого поддерева, если такое есть, либо максимум текущего дерева в противном случае.

Псевдокод
---
    int next(t: Tree, x: int)
    if empty(t) or t.max <= x
    return none;                                                          // следующего элемента нет
    if t.min > x
    return t.min;
    if empty(t.aux)
    return t.max;                                                         // в дереве не более двух элементов
    else
    if not empty(t.children[high(x)]) and t.childen[high(x)].max > low(x) 
        return merge(high(x), next(t.children[high(x)], low(x)));           // случай, когда следующее число начинается с high(x)
    else                                                                  // иначе найдем следующее непустое поддерево 
        int nextHigh = next(t.aux, high(x));
        if nextHigh == none
        return t.max;                                                     // если такого нет, вернем максимум
        else
        return merge(nextHigh, t.children[nextHigh].min);

Асимпотитка этого алгоритма *O(log(k))*

---

### 4.4 Поиск ближайшего предыдущего элемента в дереве.

Аналогичен алгоритму выше и имеет ту же асимптотику.

---

## 5 Применение

---

* Сортировка последовательности из n чисел за *O(log(k))*
* Нахождение наидлиннейшей возрастающей подпоследовательности за *O(n * log(k))*
* Алгоритм Дейкстры за *O(E * log(k))*

---

## 6 А минусы будут

---

* Возможность хранения только неотрицательных чисел
* такое дерево занимает много памяти

---

## 7 Заключение
Дерево ван Эмде Боаса - полезная структура позволяющая выполнять емкие операции за логарифмическую осимптотику, но для больших чисел оно все же не подходит.

---

## 8 Источники
---

https://habr.com/ru/articles/125499/
https://neerc.ifmo.ru/wiki/index.php?title=Дерево_ван_Эмде_Боаса