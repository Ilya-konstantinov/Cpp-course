# Алгоритм Мо + 3D Мо
Автор: Евгений Мильгунов
Группа: 11И5
## 1. Решаемая задача
Начнём с того, что определим, задачу, которую он решает. Алгоритм Мо позволяет отвечать на запросы на отрезках неизменяемого массива в оффлайн. То есть у нас есть массив $a$ длины $n$ и $q$ запросов вида $[l; r]$, где $l$ - индекс начального элемента отрезка, а $r$ - индекс конечного, соответственно. Для более наглядного примера далее будем рассматривать задачу о поиске количества различных чисел на отрезке.

## 2. Устройство алгоритма
Мы будем хранить границы и номер каждого из запросов в отдельном массиве. Далее разделим запросы на блоки по $c ≈ \sqrt{n}$. Для этого мы сначала отсортируем массив по левой границе, разделим на блоки размера $с$, а после отсортируем каждый из блоков по правой границе. Хранить мы все эти запросы будем в массиве массивов с запросами (наших блоков).

Для каждого из блоков мы будем хранить свой массив $cnt$, в котором для каждого значения будет содержаться количество элементов, равных ему. По умолчанию он будет заполнен нулями. Также создадим для каждого из блоков переменную $res$, хранящую число различных элементов на текущем отрезке или же число ненулевых элементов массива $cnt$. Изначально так же равна $0$.

Имея $cnt$ и $res$, мы можем за $O(1)$ пересчитать их при изменении какой-либо из границ отрезка на $1$ больше или меньше. Допустим, $k$ - индекс элемента, добавленного или убранного из отрезка. Тогда при увеличении размера отрезка на $1$ мы можем посмотреть на $cnt[a[k]]$ до изменения и если он равен $0$, увеличиваем res на $1$. Аналогично для уменьшения размера.

Теперь будем делать следующее: для каждого из блоков инициализируем переменные $l$ и $r$. Теперь будем идти по запросам блока и для каждого из запросов постепенно пододвигать $r$ на $1$ до равенства с правой границей запроса, выполняя все ранее описанные пересчитывания. После этого мы пододвигаем уже $l$. Когда мы закончили пододвигать границы, заносим для текущего запроса $res$ в качестве ответа в отдельный массив по номеру запроса.

В конце просто выводим содержимое массива с ответами.

## 3. Асимптотика и её доказательство
Так как изначально запросы были отсортированы по правой границе, то для каждого из блоков асимптотика изменения $r$ будет $O(n)$. $l$ же изменится для каждого из запросов не более, чем на $O(\sqrt{n})$. Тогда изменение правых границ займёт $O(n\sqrt{n})$, а изменение левых - $O(q\sqrt{n})$.

Отсюда суммарная асимптотика $O(n\sqrt{n} + q\sqrt{n})$.

## 4. 3D Мо
Существует вариация алгоритма Мо, которая позволяет также обрабатывать и запросы обновления массива. Для этого нужно ввести третий параметр у запросов типа $get$ - $t$, равный числу запросов типа $update$ до текущего.

Снова отсортируем все $get$-запросы и обработаем алгоритмом Мо, модифицированным для трёх измерений (нужно будет двигать указатель и для $t$).

Асимптотическая сложность такой вариации - $O(n^\frac{5}{3})$.

## 5. Пример реализации на C++

    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <cmath>
    
    using namespace std;
    
    vector<int> a, cnt;
    int res = 0;
    
    void add(int i) {
        if (++cnt[a[i]] == 1) {
            ++res;
        }
    }
    
    void del(int i) {
        if (--cnt[a[i]] == 0) {
            --res;
        }
    }
    
    struct query {
        int l, r, i;
    
        query() {}
    
        query(int l, int r, int i): l(l), r(r), i(i) {}
    };
    
    int block_size;
    vector<vector<query>> blocks;
    
    bool block_comp(query &a, query &b) {
        return a.r < b.r;
    }
    
    int main() {
        int n, q;
        cin >> n >> q;
        a.resize(n);
        cnt.assign(1000000, 0);
    
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
    
        block_size = sqrt(n) + 1;
        int num_blocks = (n + block_size - 1) / block_size;
        blocks.resize(num_blocks);
    
        for (int i = 0; i < q; ++i) {
            int l, r;
            cin >> l >> r;
            l--; r--;
    
            query qr(l, r, i);
            int block_idx = l / block_size;
            blocks[block_idx].push_back(qr);
        }
    
        for (auto &block : blocks) {
            if (!block.empty()) {
                sort(block.begin(), block.end(), block_comp);
            }
        }
    
        vector<int> ans(q, 0);
    
        for (int block_id = 0; block_id < num_blocks; ++block_id) {
            if (blocks[block_id].empty()) continue;
    
            int cur_l = block_id * block_size;
            int cur_r = cur_l - 1;
            res = 0;
            fill(cnt.begin(), cnt.end(), 0);
    
            for (auto &qr : blocks[block_id]) {
                int l = qr.l, r = qr.r, idx = qr.i;
    
                while (cur_r < r) {
                    add(++cur_r);
                }
                while (cur_r > r) {
                    del(cur_r--);
                }
    
                while (cur_l < l) {
                    del(cur_l++);
                }
                while (cur_l > l) {
                    add(--cur_l);
                }
    
                ans[idx] = res;
            }
        }
    
        for(int i : ans) {
            cout << i << '\n';
        }
    
        return 0;
    }

## 6. Положительные и отрицательные стороны алгоритма
### Плюсы:
1. Простота реализации
2. Универсальность (работает для широкого класса задач: xor, инверсии, количество различных элементов и т. д.)
3. Оптимальная асимптотика во многих случаях
### Минусы:
1. Алгоритм работает в оффлайн
2. Ограниченная применимость
3. Довольно сложно реализовывается добавление обновлений в 3D версии

## 7. Заключение
Алгоритм Мо — это мощный инструмент в арсенале спортивного программиста, но не панацея. Его сила в простоте и эффективности для определенного класса задач, но ограничения делают его неприменимым во многих реальных сценариях. Однако, если задача позволяет обрабатывать запросы оффлайн и требует подсчета простых вещей на отрезках — алгоритм Мо часто будет лучшим или одним из лучших решений. В остальных случаях нужно рассматривать альтернативы.
