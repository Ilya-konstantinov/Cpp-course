# Link-Cut Tree (Дерево Линка–Ката)



## Введение

**Link-Cut Tree (LCT)** — это структура данных для работы с **меняющимся деревом**. В обычных задачах по деревьям структура фиксирована: рёбра не меняются, и можно один раз сделать обход DFS. Но бывают задачи, где рёбра **добавляются и удаляются во время работы программы**, а запросы к дереву продолжают приходить.

Link-Cut Tree позволяет:
- добавлять ребро между вершинами;
- удалять ребро;
- отвечать на запросы на пути между двумя вершинами (например, найти максимум или сумму).



---

## Какую проблему решает Link-Cut Tree?

Рассмотрим лес (так называемый набор деревьев):


- вершины известны заранее;
- рёбра можно добавлять и удалять;
- нужно быстро отвечать на запросы вида:
  - находятся ли две вершины в одном дереве;
  - чему равна сумма значений на пути между `u` и `v`;
  - какой максимальный элемент на пути.

Если дерево не меняется, это легко решается с помощью обхода. Но если рёбра постоянно меняются, такие методы перестают работать.

Link-Cut Tree создан именно для таких задач.

---

## Основная идея

Главная идея такая:

> Любое дерево можно представить как набор путей.

Link-Cut Tree динамически разбивает дерево на **предпочитаемые пути** и хранит каждый такой путь в виде **splay-дерева** (самобалансирующегося бинарного дерева поиска).

Когда структура дерева меняется или приходит новый запрос, эти пути перестраиваются.

Важно: мы **не храним всё дерево целиком**, а только пути, которые сейчас удобны для обработки запросов.

---

## Почему именно splay-дерево?

Splay-дерево выбрано по трём причинам:
1. Оно само балансируется.
2. Не требует хранения высот или цветов.
3. Имеет амортизированную сложность O(log n).

Каждая операция в LCT сводится к небольшому числу операций в splay-дереве.

---

## Ключевая операция: `access(v)`

Операция `access(v)` — это основа всей структуры.

Что она делает:
- перестраивает дерево так, чтобы путь от вершины `v` до корня стал **одним предпочтительным путём**;
- этот путь полностью оказывается внутри одного splay-дерева.


> После `access(v)` мы можем быстро работать с путём от `v` до корня.

Все остальные операции используют `access`.

---

## Операция `makeroot(v)`

По умолчанию дерево считается ориентированным к корню. Но часто нужно работать с неориентированным деревом.

`makeroot(v)` делает вершину `v` корнем дерева.

Как это работает:
1. вызывается `access(v)`;
2. путь разворачивается (используется ленивый флаг разворота).

Теперь `v` — корень.

---

## Добавление ребра: `link(u, v)`

Операция добавляет ребро между вершинами `u` и `v`.

Алгоритм:
1. `makeroot(u)` — делаем `u` корнем;
2. проверяем, что `u` и `v` в разных деревьях;
3. соединяем `u` и `v`.

Если бы не делали `makeroot`, могли бы случайно создать цикл.

---

## Удаление ребра: `cut(u, v)`

Удаляет ребро между `u` и `v`.

Алгоритм:
1. `makeroot(u)`;
2. `access(v)` — теперь путь `u → v` в одном splay-дереве;
3. удаляем ребро между ними.

---

## Запросы на пути

Чтобы выполнить запрос на пути между `u` и `v`:
1. `makeroot(u)`;
2. `access(v)`;

После этого весь путь `u → v` лежит в одном splay-дереве, и мы можем:
- найти сумму;
- найти максимум;
- выполнить обновление.

---


Рассмотрим конкретный пример.

### Исходное дерево

Пусть у нас есть дерево из 5 вершин:

```
1
|
2
|
3
/ \
4  5
```

Рёбра: (1–2), (2–3), (3–4), (3–5)

Предположим, что в каждой вершине хранится некоторое число, и мы хотим находить сумму на пути.

---

### Пример запроса: сумма на пути от 4 до 1

Нам нужно найти путь `4 → 3 → 2 → 1`.

Что делает Link-Cut Tree:

1. `makeroot(4)`
   - вершина 4 становится корнем дерева;
   - путь от 4 вверх разворачивается.

2. `access(1)`
   - структура перестраивается так, что путь от 4 до 1 становится **одним предпочтительным путём**;
   - этот путь хранится внутри одного splay-дерева.

После этого внутри одного splay-дерева находятся вершины:

```
4 — 3 — 2 — 1
```

Теперь сумма на пути считается как обычная сумма на отрезке в бинарном дереве.

---

### Как это выглядит визуально

До запроса дерево логически выглядело так:

```
1
|
2
|
3
/ \
4  5
```

После `makeroot(4)` и `access(1)`:

```
4
|
3
|
2
|
1
```

Вершина 5 при этом **не потерялась** — она остаётся в дереве, но временно не входит в предпочтительный путь.

---

### Пример изменения структуры: удаление ребра

Теперь выполним операцию `cut(3, 5)`.

Алгоритм:
1. `makeroot(3)`;
2. `access(5)`;
3. удаляем ребро между 3 и 5.

Результат:
- вершина 5 становится отдельным деревом;
- остальные вершины остаются связанными.

---

### Почему это эффективно


- дерево **не перестраивается** полностью;
- перестраивается только путь, который нужен прямо сейчас;
- все остальные части дерева не изменяются.

Именно поэтому Link-Cut Tree работает быстро даже при большом количестве изменений.

---

## Доказательство асимптотики

### Шаг 1. Сложность операций splay-дерева

Из теории известно:
- каждая операция splay-дерева (rotate, splay) имеет **амортизированную сложность O(log n)**;
- это доказано через потенциальный метод.

Это означает, что за длинную последовательность операций средняя стоимость одной операции — O(log n).

---

### Шаг 2. Сколько splay-операций делает `access`?

Операция `access(v)`:
- поднимается от `v` к корню;
- на каждом шаге выполняет ограниченное число splay-операций.


> Каждый вызов `access` делает **O(log n)** splay-операций.

---

### Шаг 3. Асимптотика основных операций

Каждая операция:
- `link`
- `cut`
- `makeroot`
- запрос на пути

состоит из:
- фиксированного числа вызовов `access`;
- небольшого числа дополнительных операций.

Так как:
- один `access` = O(log n) амортизированно;
- число `access` в каждой операции ограничено константой;

получаем:

> **Все основные операции Link-Cut Tree имеют амортизированную сложность O(log n).**

---
Почему именно splay-дерево?

Splay-дерево выбрано по трём причинам:

Оно само балансируется.

Не требует хранения высот или цветов.

Имеет доказанную амортизированную сложность O(log n).

Каждая операция в LCT сводится к небольшому числу операций в splay-дереве.

---
## Заключение

Link-Cut Tree — это мощная структура данных для работы с динамическими деревьями. Она позволяет эффективно выполнять сложные запросы, но требует глубокого понимания алгоритмов и аккуратной реализации.

- добавлять ребро между вершинами;
- удалять ребро;
- отвечать на запросы на пути между двумя вершинами (например, найти максимум или сумму).

Эта структура считается очень сложной и обычно изучается только на продвинутом уровне.

---

## Источники

Sleator D. D., Tarjan R. E. A Data Structure for Dynamic Trees. Journal of Computer and System Sciences, 1983.

Link-Cut Tree - Викиконспекты

Link-Cut Tree - geeksforgeeks

Link-Cut Tree - grokipedia

